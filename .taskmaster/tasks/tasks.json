{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize Monorepo and Configure Project Structure",
        "description": "Set up pnpm workspace monorepo with apps/web (Nuxt 4), apps/api (NestJS), and packages/types directories. Configure TypeScript, linting, and shared tooling.",
        "details": "1. Initialize pnpm workspace:\n```bash\npnpm init\n```\n\n2. Create pnpm-workspace.yaml:\n```yaml\npackages:\n  - 'apps/*'\n  - 'packages/*'\n```\n\n3. Create directory structure:\n```\ntelegram-crawler/\n├── apps/\n│   ├── web/\n│   └── api/\n├── packages/\n│   └── types/\n├── package.json\n├── pnpm-workspace.yaml\n└── .gitignore\n```\n\n4. Install root dependencies:\n```bash\npnpm add -D -w typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier eslint\n```\n\n5. Create root tsconfig.json with common settings:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"resolveJsonModule\": true\n  }\n}\n```\n\n6. Create packages/types/package.json:\n```json\n{\n  \"name\": \"@telegram-crawler/types\",\n  \"version\": \"0.0.1\",\n  \"main\": \"./index.ts\",\n  \"types\": \"./index.ts\"\n}\n```\n\n7. Create shared types in packages/types/index.ts:\n```typescript\nexport interface User {\n  id: string;\n  email: string;\n  name?: string;\n  role: 'admin' | 'user';\n  isActive: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Channel {\n  id: string;\n  telegramId: string;\n  username?: string;\n  title: string;\n  description?: string;\n  subscriberCount?: number;\n  photoUrl?: string;\n  topic: string;\n  channelType: 'news' | 'personal_blog' | 'official';\n  isActive: boolean;\n  lastCrawledAt?: Date;\n  lastPostId?: string;\n  crawlPriority: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Post {\n  id: string;\n  channelId: string;\n  telegramPostId: string;\n  textContent?: string;\n  hasMedia: boolean;\n  mediaType?: 'photo' | 'video' | 'document';\n  mediaFileId?: string;\n  mediaThumbnail?: string;\n  views?: number;\n  forwards?: number;\n  postedAt: Date;\n  isEdited: boolean;\n  editedAt?: Date;\n  isDeleted: boolean;\n  deletedAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface AuthTokens {\n  accessToken: string;\n  refreshToken: string;\n}\n\nexport interface LoginDto {\n  email: string;\n  password: string;\n}\n\nexport interface RefreshTokenDto {\n  refreshToken: string;\n}\n```",
        "testStrategy": "1. Verify pnpm workspace configuration:\n```bash\npnpm -r list\n```\n2. Verify TypeScript compilation:\n```bash\npnpm -r exec tsc --noEmit\n```\n3. Check that packages/types can be imported from apps\n4. Verify .gitignore excludes node_modules, dist, .env files\n5. Test shared type imports work across packages",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 3,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down the monorepo initialization into: 1) Create workspace configuration and directory structure, 2) Set up root-level TypeScript and ESLint configs, 3) Create shared types package with initial interfaces, 4) Configure package linking and workspace dependencies, 5) Set up .gitignore and verify workspace tooling works",
        "updatedAt": "2025-11-30T16:29:45.833Z"
      },
      {
        "id": "2",
        "title": "Set Up NestJS Backend with Core Modules",
        "description": "Initialize NestJS application in apps/api with module structure, TypeORM configuration, environment management, and error handling foundation.",
        "details": "1. Initialize NestJS in apps/api:\n```bash\ncd apps/api\nnpnx @nestjs/cli new . --skip-git --package-manager pnpm\n```\n\n2. Install dependencies:\n```bash\npnpm add @nestjs/config @nestjs/typeorm typeorm pg @nestjs/jwt @nestjs/passport passport passport-jwt bcrypt class-validator class-transformer\npnpm add -D @types/bcrypt @types/passport-jwt\n```\n\n3. Create apps/api/src/config/database.config.ts:\n```typescript\nimport { registerAs } from '@nestjs/config';\nimport { TypeOrmModuleOptions } from '@nestjs/typeorm';\n\nexport default registerAs('database', (): TypeOrmModuleOptions => ({\n  type: 'postgres',\n  host: process.env.DB_HOST || 'localhost',\n  port: parseInt(process.env.DB_PORT || '5432'),\n  username: process.env.DB_USERNAME || 'telegram_crawler',\n  password: process.env.DB_PASSWORD,\n  database: process.env.DB_NAME || 'telegram_crawler',\n  entities: [__dirname + '/../**/*.entity{.ts,.js}'],\n  migrations: [__dirname + '/../database/migrations/*{.ts,.js}'],\n  synchronize: false,\n  logging: process.env.NODE_ENV === 'development',\n}));\n```\n\n4. Create apps/api/src/config/jwt.config.ts:\n```typescript\nimport { registerAs } from '@nestjs/config';\n\nexport default registerAs('jwt', () => ({\n  accessSecret: process.env.JWT_ACCESS_SECRET,\n  refreshSecret: process.env.JWT_REFRESH_SECRET,\n  accessExpiresIn: '15m',\n  refreshExpiresIn: '7d',\n}));\n```\n\n5. Create apps/api/src/common/filters/http-exception.filter.ts:\n```typescript\nimport { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus } from '@nestjs/common';\nimport { Request, Response } from 'express';\n\n@Catch(HttpException)\nexport class HttpExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    const status = exception.getStatus();\n    const exceptionResponse = exception.getResponse();\n\n    response.status(status).json({\n      statusCode: status,\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      message: typeof exceptionResponse === 'string' ? exceptionResponse : (exceptionResponse as any).message,\n    });\n  }\n}\n```\n\n6. Create apps/api/src/common/decorators/current-user.decorator.ts:\n```typescript\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request.user;\n  },\n);\n```\n\n7. Update apps/api/src/app.module.ts:\n```typescript\nimport { Module } from '@nestjs/common';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport databaseConfig from './config/database.config';\nimport jwtConfig from './config/jwt.config';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      isGlobal: true,\n      load: [databaseConfig, jwtConfig],\n    }),\n    TypeOrmModule.forRootAsync({\n      inject: [ConfigService],\n      useFactory: (config: ConfigService) => config.get('database'),\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n8. Create .env.example:\n```\nDB_HOST=localhost\nDB_PORT=5432\nDB_USERNAME=telegram_crawler\nDB_PASSWORD=your_password\nDB_NAME=telegram_crawler\nJWT_ACCESS_SECRET=your_access_secret_min_32_chars\nJWT_REFRESH_SECRET=your_refresh_secret_min_32_chars\nNODE_ENV=development\n```",
        "testStrategy": "1. Verify NestJS app starts:\n```bash\npnpm dev\n```\n2. Test environment loading with missing .env (should fail gracefully)\n3. Unit test HttpExceptionFilter with mock exceptions\n4. Unit test CurrentUser decorator with mock ExecutionContext\n5. Verify ConfigModule loads all config files\n6. Test TypeORM configuration object structure",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Expand into: 1) Initialize NestJS application with CLI, 2) Configure environment management and config module, 3) Set up TypeORM with database configuration, 4) Create common utilities (filters, decorators, pipes), 5) Configure JWT module settings, 6) Write integration tests for app bootstrap and config loading",
        "updatedAt": "2025-11-30T17:25:38.957Z"
      },
      {
        "id": "3",
        "title": "Create Database Schema and TypeORM Entities",
        "description": "Define TypeORM entities for User, Channel, Post, and RefreshToken with proper relationships, indexes, and migrations.",
        "details": "1. Create apps/api/src/database/entities/user.entity.ts:\n```typescript\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, OneToMany } from 'typeorm';\nimport { RefreshToken } from './refresh-token.entity';\n\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ unique: true })\n  email: string;\n\n  @Column({ name: 'password_hash' })\n  passwordHash: string;\n\n  @Column({ nullable: true })\n  name?: string;\n\n  @Column({ type: 'enum', enum: ['admin', 'user'], default: 'user' })\n  role: 'admin' | 'user';\n\n  @Column({ name: 'is_active', default: true })\n  isActive: boolean;\n\n  @OneToMany(() => RefreshToken, token => token.user)\n  refreshTokens: RefreshToken[];\n\n  @CreateDateColumn({ name: 'created_at' })\n  createdAt: Date;\n\n  @UpdateDateColumn({ name: 'updated_at' })\n  updatedAt: Date;\n}\n```\n\n2. Create apps/api/src/database/entities/refresh-token.entity.ts:\n```typescript\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, JoinColumn, Index } from 'typeorm';\nimport { User } from './user.entity';\n\n@Entity('refresh_tokens')\nexport class RefreshToken {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ name: 'user_id' })\n  userId: string;\n\n  @ManyToOne(() => User, user => user.refreshTokens, { onDelete: 'CASCADE' })\n  @JoinColumn({ name: 'user_id' })\n  user: User;\n\n  @Column({ name: 'token_hash' })\n  @Index()\n  tokenHash: string;\n\n  @Column({ name: 'expires_at' })\n  expiresAt: Date;\n\n  @Column({ name: 'is_revoked', default: false })\n  isRevoked: boolean;\n\n  @CreateDateColumn({ name: 'created_at' })\n  createdAt: Date;\n}\n```\n\n3. Create apps/api/src/database/entities/channel.entity.ts:\n```typescript\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, OneToMany, Index } from 'typeorm';\nimport { Post } from './post.entity';\n\n@Entity('channels')\nexport class Channel {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ name: 'telegram_id', type: 'bigint', unique: true })\n  @Index()\n  telegramId: string;\n\n  @Column({ nullable: true, unique: true })\n  @Index()\n  username?: string;\n\n  @Column()\n  title: string;\n\n  @Column({ type: 'text', nullable: true })\n  description?: string;\n\n  @Column({ name: 'subscriber_count', nullable: true })\n  subscriberCount?: number;\n\n  @Column({ name: 'photo_url', nullable: true })\n  photoUrl?: string;\n\n  @Column()\n  @Index()\n  topic: string;\n\n  @Column({ name: 'channel_type', type: 'enum', enum: ['news', 'personal_blog', 'official'] })\n  channelType: 'news' | 'personal_blog' | 'official';\n\n  @Column({ name: 'is_active', default: true })\n  @Index()\n  isActive: boolean;\n\n  @Column({ name: 'last_crawled_at', nullable: true })\n  lastCrawledAt?: Date;\n\n  @Column({ name: 'last_post_id', type: 'bigint', nullable: true })\n  lastPostId?: string;\n\n  @Column({ name: 'crawl_priority', default: 5 })\n  crawlPriority: number;\n\n  @OneToMany(() => Post, post => post.channel)\n  posts: Post[];\n\n  @CreateDateColumn({ name: 'created_at' })\n  createdAt: Date;\n\n  @UpdateDateColumn({ name: 'updated_at' })\n  updatedAt: Date;\n}\n```\n\n4. Create apps/api/src/database/entities/post.entity.ts:\n```typescript\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToOne, JoinColumn, Index } from 'typeorm';\nimport { Channel } from './channel.entity';\n\n@Entity('posts')\n@Index(['channelId', 'postedAt'])\n@Index('post_search_idx', { synchronize: false }) // Created in migration\nexport class Post {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ name: 'channel_id' })\n  channelId: string;\n\n  @ManyToOne(() => Channel, channel => channel.posts, { onDelete: 'CASCADE' })\n  @JoinColumn({ name: 'channel_id' })\n  channel: Channel;\n\n  @Column({ name: 'telegram_post_id', type: 'bigint' })\n  @Index()\n  telegramPostId: string;\n\n  @Column({ name: 'text_content', type: 'text', nullable: true })\n  textContent?: string;\n\n  @Column({ name: 'has_media', default: false })\n  hasMedia: boolean;\n\n  @Column({ name: 'media_type', type: 'enum', enum: ['photo', 'video', 'document'], nullable: true })\n  mediaType?: 'photo' | 'video' | 'document';\n\n  @Column({ name: 'media_file_id', nullable: true })\n  mediaFileId?: string;\n\n  @Column({ name: 'media_thumbnail', nullable: true })\n  mediaThumbnail?: string;\n\n  @Column({ nullable: true })\n  views?: number;\n\n  @Column({ nullable: true })\n  forwards?: number;\n\n  @Column({ name: 'posted_at' })\n  @Index()\n  postedAt: Date;\n\n  @Column({ name: 'is_edited', default: false })\n  isEdited: boolean;\n\n  @Column({ name: 'edited_at', nullable: true })\n  editedAt?: Date;\n\n  @Column({ name: 'is_deleted', default: false })\n  isDeleted: boolean;\n\n  @Column({ name: 'deleted_at', nullable: true })\n  deletedAt?: Date;\n\n  @CreateDateColumn({ name: 'created_at' })\n  createdAt: Date;\n\n  @UpdateDateColumn({ name: 'updated_at' })\n  updatedAt: Date;\n}\n```\n\n5. Create migration:\n```bash\npnpm typeorm migration:generate -n InitialSchema\n```\n\n6. Add full-text search index in migration:\n```typescript\nawait queryRunner.query(`\n  ALTER TABLE posts ADD COLUMN search_vector tsvector;\n  CREATE INDEX post_search_idx ON posts USING gin(search_vector);\n  CREATE OR REPLACE FUNCTION posts_search_vector_update() RETURNS trigger AS $$\n  BEGIN\n    NEW.search_vector := to_tsvector('english', COALESCE(NEW.text_content, ''));\n    RETURN NEW;\n  END\n  $$ LANGUAGE plpgsql;\n  CREATE TRIGGER posts_search_vector_update_trigger\n  BEFORE INSERT OR UPDATE ON posts\n  FOR EACH ROW EXECUTE FUNCTION posts_search_vector_update();\n`);\n```",
        "testStrategy": "1. Run migrations:\n```bash\npnpm typeorm migration:run\n```\n2. Verify all tables created in PostgreSQL\n3. Test entity relationships with repository operations\n4. Verify indexes exist using:\n```sql\nSELECT * FROM pg_indexes WHERE tablename IN ('users', 'channels', 'posts', 'refresh_tokens');\n```\n5. Test full-text search trigger:\n```sql\nINSERT INTO posts (channel_id, telegram_post_id, text_content, posted_at) VALUES (...); SELECT search_vector FROM posts WHERE id = ...;\n```\n6. Unit test entity validation rules",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Divide into: 1) Design and create User entity with authentication fields, 2) Create RefreshToken entity with proper indexes, 3) Design Channel entity with Telegram-specific fields, 4) Create Post entity with media and search support, 5) Generate and review initial migration, 6) Implement PostgreSQL full-text search trigger and indexes, 7) Test entity relationships and constraints",
        "updatedAt": "2025-11-30T20:47:26.675Z"
      },
      {
        "id": "4",
        "title": "Implement Authentication Module with JWT",
        "description": "Build complete authentication system with user registration, login, JWT access/refresh tokens, password hashing, and auth guards.",
        "details": "1. Create apps/api/src/modules/users/users.module.ts:\n```typescript\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { User } from '../../database/entities/user.entity';\nimport { UsersService } from './users.service';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n```\n\n2. Create apps/api/src/modules/users/users.service.ts:\n```typescript\nimport { Injectable, ConflictException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { User } from '../../database/entities/user.entity';\nimport * as bcrypt from 'bcrypt';\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n  ) {}\n\n  async create(email: string, password: string, name?: string): Promise<User> {\n    const existing = await this.usersRepository.findOne({ where: { email } });\n    if (existing) throw new ConflictException('Email already registered');\n    \n    const passwordHash = await bcrypt.hash(password, 12);\n    const user = this.usersRepository.create({ email, passwordHash, name });\n    return this.usersRepository.save(user);\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    return this.usersRepository.findOne({ where: { email } });\n  }\n\n  async findById(id: string): Promise<User | null> {\n    return this.usersRepository.findOne({ where: { id } });\n  }\n\n  async validatePassword(user: User, password: string): Promise<boolean> {\n    return bcrypt.compare(password, user.passwordHash);\n  }\n}\n```\n\n3. Create apps/api/src/modules/auth/auth.module.ts:\n```typescript\nimport { Module } from '@nestjs/common';\nimport { JwtModule } from '@nestjs/jwt';\nimport { PassportModule } from '@nestjs/passport';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { RefreshToken } from '../../database/entities/refresh-token.entity';\nimport { UsersModule } from '../users/users.module';\nimport { AuthService } from './auth.service';\nimport { AuthController } from './auth.controller';\nimport { JwtStrategy } from './strategies/jwt.strategy';\nimport { JwtAuthGuard } from './guards/jwt-auth.guard';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    TypeOrmModule.forFeature([RefreshToken]),\n    JwtModule.registerAsync({\n      imports: [ConfigModule],\n      inject: [ConfigService],\n      useFactory: (config: ConfigService) => ({\n        secret: config.get('jwt.accessSecret'),\n        signOptions: { expiresIn: config.get('jwt.accessExpiresIn') },\n      }),\n    }),\n  ],\n  providers: [AuthService, JwtStrategy, JwtAuthGuard],\n  controllers: [AuthController],\n  exports: [JwtAuthGuard],\n})\nexport class AuthModule {}\n```\n\n4. Create apps/api/src/modules/auth/auth.service.ts:\n```typescript\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { RefreshToken } from '../../database/entities/refresh-token.entity';\nimport { UsersService } from '../users/users.service';\nimport * as bcrypt from 'bcrypt';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private usersService: UsersService,\n    private jwtService: JwtService,\n    private configService: ConfigService,\n    @InjectRepository(RefreshToken)\n    private refreshTokenRepository: Repository<RefreshToken>,\n  ) {}\n\n  async login(email: string, password: string) {\n    const user = await this.usersService.findByEmail(email);\n    if (!user || !user.isActive) throw new UnauthorizedException('Invalid credentials');\n    \n    const isValid = await this.usersService.validatePassword(user, password);\n    if (!isValid) throw new UnauthorizedException('Invalid credentials');\n    \n    return this.generateTokens(user.id);\n  }\n\n  async generateTokens(userId: string) {\n    const payload = { sub: userId };\n    \n    const accessToken = this.jwtService.sign(payload);\n    const refreshToken = this.jwtService.sign(payload, {\n      secret: this.configService.get('jwt.refreshSecret'),\n      expiresIn: this.configService.get('jwt.refreshExpiresIn'),\n    });\n    \n    const tokenHash = await bcrypt.hash(refreshToken, 10);\n    const expiresAt = new Date();\n    expiresAt.setDate(expiresAt.getDate() + 7);\n    \n    await this.refreshTokenRepository.save({\n      userId,\n      tokenHash,\n      expiresAt,\n    });\n    \n    return { accessToken, refreshToken };\n  }\n\n  async refreshTokens(refreshToken: string) {\n    try {\n      const payload = this.jwtService.verify(refreshToken, {\n        secret: this.configService.get('jwt.refreshSecret'),\n      });\n      \n      const tokens = await this.refreshTokenRepository.find({\n        where: { userId: payload.sub, isRevoked: false },\n      });\n      \n      let isValid = false;\n      for (const token of tokens) {\n        if (await bcrypt.compare(refreshToken, token.tokenHash)) {\n          isValid = true;\n          await this.refreshTokenRepository.update(token.id, { isRevoked: true });\n          break;\n        }\n      }\n      \n      if (!isValid) throw new UnauthorizedException();\n      return this.generateTokens(payload.sub);\n    } catch {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n  }\n\n  async logout(refreshToken: string) {\n    const payload = this.jwtService.decode(refreshToken) as any;\n    if (payload?.sub) {\n      await this.refreshTokenRepository.update(\n        { userId: payload.sub, isRevoked: false },\n        { isRevoked: true },\n      );\n    }\n  }\n}\n```\n\n5. Create apps/api/src/modules/auth/strategies/jwt.strategy.ts:\n```typescript\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { UsersService } from '../../users/users.service';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(\n    private configService: ConfigService,\n    private usersService: UsersService,\n  ) {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      secretOrKey: configService.get('jwt.accessSecret'),\n    });\n  }\n\n  async validate(payload: any) {\n    const user = await this.usersService.findById(payload.sub);\n    if (!user || !user.isActive) throw new UnauthorizedException();\n    return user;\n  }\n}\n```\n\n6. Create apps/api/src/modules/auth/guards/jwt-auth.guard.ts:\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {}\n```\n\n7. Create apps/api/src/modules/auth/auth.controller.ts:\n```typescript\nimport { Controller, Post, Body, UseGuards, HttpCode, HttpStatus } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { JwtAuthGuard } from './guards/jwt-auth.guard';\nimport { CurrentUser } from '../../common/decorators/current-user.decorator';\nimport { User } from '../../database/entities/user.entity';\n\n@Controller('auth')\nexport class AuthController {\n  constructor(private authService: AuthService) {}\n\n  @Post('login')\n  @HttpCode(HttpStatus.OK)\n  async login(@Body() body: { email: string; password: string }) {\n    return this.authService.login(body.email, body.password);\n  }\n\n  @Post('refresh')\n  @HttpCode(HttpStatus.OK)\n  async refresh(@Body() body: { refreshToken: string }) {\n    return this.authService.refreshTokens(body.refreshToken);\n  }\n\n  @Post('logout')\n  @HttpCode(HttpStatus.OK)\n  async logout(@Body() body: { refreshToken: string }) {\n    await this.authService.logout(body.refreshToken);\n    return { message: 'Logged out successfully' };\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Post('me')\n  @HttpCode(HttpStatus.OK)\n  async me(@CurrentUser() user: User) {\n    const { passwordHash, ...userData } = user;\n    return userData;\n  }\n}\n```",
        "testStrategy": "1. Integration tests for AuthController endpoints:\n   - POST /auth/login with valid credentials returns tokens\n   - POST /auth/login with invalid credentials returns 401\n   - POST /auth/refresh with valid token returns new tokens\n   - POST /auth/logout revokes refresh token\n   - POST /auth/me with valid JWT returns user data\n2. Unit tests for AuthService:\n   - generateTokens creates access and refresh tokens\n   - refreshTokens validates and rotates tokens\n   - logout revokes all user refresh tokens\n3. Unit tests for UsersService:\n   - create hashes password with bcrypt cost 12\n   - validatePassword correctly compares hashes\n4. Test JwtStrategy validates user and rejects inactive users\n5. Test JwtAuthGuard blocks requests without valid token\n6. E2E test: login -> access protected route -> refresh -> logout -> fail to access",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create UsersModule and UsersService with bcrypt password hashing",
            "description": "Implement the Users module with TypeORM repository integration, user creation with password hashing using bcrypt (cost factor 12), email validation, and user lookup methods.",
            "dependencies": [],
            "details": "Create apps/api/src/modules/users/users.module.ts with TypeOrmModule.forFeature([User]). Implement UsersService with: create() method that checks for existing email, hashes password with bcrypt.hash(password, 12), and saves user; findByEmail() and findById() methods using TypeORM repository; validatePassword() using bcrypt.compare(). Handle ConflictException for duplicate emails.",
            "status": "pending",
            "testStrategy": "Unit tests: create() throws ConflictException for duplicate email, create() hashes password correctly (verify hash differs from plaintext), findByEmail() returns user or null, validatePassword() returns true for correct password and false for incorrect password. Mock TypeORM repository.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement AuthService with JWT token generation logic",
            "description": "Build AuthService with login method, JWT access/refresh token generation, and token payload creation. Integrate JwtService and ConfigService for token signing.",
            "dependencies": [
              1
            ],
            "details": "Create apps/api/src/modules/auth/auth.service.ts. Implement login() method: validate user exists and isActive, check password with UsersService.validatePassword(), call generateTokens(). Implement generateTokens(): create payload { sub: userId }, sign accessToken with jwtService.sign(), sign refreshToken with custom secret/expiry from config. Store refresh token hash in RefreshToken entity with expiresAt (7 days). Return { accessToken, refreshToken }.",
            "status": "pending",
            "testStrategy": "Unit tests: login() throws UnauthorizedException for invalid credentials, login() throws for inactive user, login() returns tokens for valid credentials, generateTokens() creates valid JWT payload, generateTokens() saves hashed refresh token to database. Mock UsersService, JwtService, and RefreshToken repository.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build JWT refresh token rotation mechanism with revocation",
            "description": "Implement secure refresh token rotation that prevents token reuse by revoking old tokens when new ones are issued, with database-backed token validation.",
            "dependencies": [
              2
            ],
            "details": "In AuthService, implement refreshTokens() method: verify refresh token with JwtService.verify() using refreshSecret from config, query RefreshToken repository for non-revoked tokens matching userId, iterate and compare token hash with bcrypt.compare(), if match found revoke it (set isRevoked=true), generate new token pair with generateTokens(). Implement logout() method: decode refresh token, revoke all active tokens for that userId. Handle token expiry and invalid token errors.",
            "status": "pending",
            "testStrategy": "Unit tests: refreshTokens() throws UnauthorizedException for invalid token, refreshTokens() revokes old token before issuing new one, refreshTokens() prevents reuse of same token twice, logout() revokes all user tokens, expired tokens are rejected. Integration test: verify token rotation prevents replay attacks.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create JwtStrategy and integrate with Passport.js",
            "description": "Implement Passport JWT strategy for access token validation, user lookup, and request injection. Configure strategy with JWT extraction and secret.",
            "dependencies": [
              1
            ],
            "details": "Create apps/api/src/modules/auth/strategies/jwt.strategy.ts extending PassportStrategy(Strategy). Configure constructor: use ExtractJwt.fromAuthHeaderAsBearerToken(), get secretOrKey from ConfigService (jwt.accessSecret). Implement validate(payload): extract userId from payload.sub, fetch user with UsersService.findById(), throw UnauthorizedException if user not found or inactive, return user object (will be attached to request).",
            "status": "pending",
            "testStrategy": "Unit tests: validate() returns user for valid payload, validate() throws UnauthorizedException for non-existent user, validate() throws for inactive user, JWT extraction works from Authorization header. Integration test: verify strategy integrates with Passport and attaches user to request.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement JwtAuthGuard for route protection",
            "description": "Create authentication guard extending Passport's AuthGuard to protect routes requiring valid JWT access tokens.",
            "dependencies": [
              4
            ],
            "details": "Create apps/api/src/modules/auth/guards/jwt-auth.guard.ts as @Injectable() class extending AuthGuard('jwt'). No custom logic needed - delegates to JwtStrategy. Create apps/api/src/common/decorators/current-user.decorator.ts using createParamDecorator to extract user from request.user. Export JwtAuthGuard from AuthModule for use in other modules.",
            "status": "pending",
            "testStrategy": "Integration tests: @UseGuards(JwtAuthGuard) blocks requests without token (401), blocks requests with invalid token (401), allows requests with valid token, @CurrentUser() decorator injects user object. Test with mock controller endpoint.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create AuthModule and AuthController with all endpoints",
            "description": "Build complete authentication controller with login, refresh, logout, and me endpoints. Configure AuthModule with JwtModule, PassportModule, and dependencies.",
            "dependencies": [
              2,
              3,
              5
            ],
            "details": "Create apps/api/src/modules/auth/auth.module.ts: import UsersModule, PassportModule, TypeOrmModule.forFeature([RefreshToken]), JwtModule.registerAsync() with ConfigService for accessSecret/expiresIn. Create AuthController with: POST /auth/login (email, password) returning tokens, POST /auth/refresh (refreshToken) returning new tokens, POST /auth/logout (refreshToken) revoking token, POST /auth/me with @UseGuards(JwtAuthGuard) returning current user (exclude passwordHash). Use @HttpCode(HttpStatus.OK) for POST endpoints.",
            "status": "pending",
            "testStrategy": "Integration tests for AuthController: POST /auth/login with valid credentials returns accessToken and refreshToken, invalid credentials returns 401, POST /auth/refresh with valid token returns new tokens, POST /auth/logout revokes token, POST /auth/me without token returns 401, POST /auth/me with valid token returns user data without passwordHash.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Write unit tests for token refresh flow and security logic",
            "description": "Create comprehensive unit tests for token generation, refresh rotation, revocation logic, and bcrypt operations to ensure security requirements are met.",
            "dependencies": [
              3
            ],
            "details": "Create apps/api/src/modules/auth/__tests__/auth.service.spec.ts. Test token refresh flow: verify token rotation revokes old token, prevents token reuse, handles expired tokens, validates token hash comparison. Test security: bcrypt hashing uses cost factor 12, refresh tokens are hashed before storage, token expiry is set correctly (7 days), concurrent refresh requests are handled safely. Mock RefreshToken repository, JwtService, ConfigService.",
            "status": "pending",
            "testStrategy": "Unit test coverage: token refresh rotation (revocation + new generation), token reuse prevention (second use fails), bcrypt hash verification, token expiry validation, concurrent refresh handling, logout revokes all user tokens. Aim for 100% coverage of AuthService refresh logic.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Create integration tests for complete authentication flows",
            "description": "Build end-to-end integration tests covering registration, login, token refresh, logout, and protected route access across the entire authentication system.",
            "dependencies": [
              6
            ],
            "details": "Create apps/api/test/auth.e2e-spec.ts. Test complete flows: user registration → login → access protected endpoint → refresh token → access again → logout → verify token invalid. Test error cases: login with wrong password, refresh with invalid token, access protected route without token, access with expired token. Use TestingModule with real database (test container or in-memory), send HTTP requests to controller, verify database state (tokens stored/revoked), verify JWT payload structure.",
            "status": "pending",
            "testStrategy": "E2E test scenarios: complete auth flow (register→login→refresh→logout), token expiry handling, protected route access with valid/invalid tokens, refresh token rotation in real HTTP requests, verify RefreshToken entities in database, verify bcrypt hashes stored correctly. Use supertest for HTTP requests.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Break down into: 1) Create UsersService with password hashing (bcrypt), 2) Implement AuthService with token generation logic, 3) Build JWT refresh token rotation mechanism, 4) Create JwtStrategy and integrate with Passport, 5) Implement JwtAuthGuard, 6) Create AuthController with all endpoints, 7) Write unit tests for token refresh flow, 8) Create integration tests for authentication flows"
      },
      {
        "id": "5",
        "title": "Build Channel Management Module",
        "description": "Implement CRUD operations for channels with Telegram metadata resolution, topic assignment, channel type management, and filtering capabilities.",
        "details": "1. Create apps/api/src/modules/channels/dto/create-channel.dto.ts:\n```typescript\nimport { IsString, IsEnum, IsOptional, IsInt, Min, Max } from 'class-validator';\n\nexport class CreateChannelDto {\n  @IsString()\n  usernameOrLink: string;\n\n  @IsString()\n  topic: string;\n\n  @IsEnum(['news', 'personal_blog', 'official'])\n  channelType: 'news' | 'personal_blog' | 'official';\n\n  @IsOptional()\n  @IsInt()\n  @Min(1)\n  @Max(10)\n  crawlPriority?: number;\n}\n```\n\n2. Create apps/api/src/modules/channels/dto/update-channel.dto.ts:\n```typescript\nimport { IsString, IsEnum, IsOptional, IsInt, Min, Max, IsBoolean } from 'class-validator';\n\nexport class UpdateChannelDto {\n  @IsOptional()\n  @IsString()\n  topic?: string;\n\n  @IsOptional()\n  @IsEnum(['news', 'personal_blog', 'official'])\n  channelType?: 'news' | 'personal_blog' | 'official';\n\n  @IsOptional()\n  @IsInt()\n  @Min(1)\n  @Max(10)\n  crawlPriority?: number;\n\n  @IsOptional()\n  @IsBoolean()\n  isActive?: boolean;\n}\n```\n\n3. Create apps/api/src/modules/channels/channels.service.ts:\n```typescript\nimport { Injectable, NotFoundException, ConflictException, BadRequestException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Channel } from '../../database/entities/channel.entity';\nimport { CreateChannelDto } from './dto/create-channel.dto';\nimport { UpdateChannelDto } from './dto/update-channel.dto';\n\n@Injectable()\nexport class ChannelsService {\n  constructor(\n    @InjectRepository(Channel)\n    private channelsRepository: Repository<Channel>,\n  ) {}\n\n  private parseUsername(input: string): string {\n    // Handle @username, t.me/username, https://t.me/username\n    const patterns = [\n      /^@([a-zA-Z0-9_]+)$/,\n      /^t\\.me\\/([a-zA-Z0-9_]+)$/,\n      /^https?:\\/\\/t\\.me\\/([a-zA-Z0-9_]+)$/,\n    ];\n    \n    for (const pattern of patterns) {\n      const match = input.match(pattern);\n      if (match) return match[1];\n    }\n    \n    throw new BadRequestException('Invalid channel username or link format');\n  }\n\n  async create(dto: CreateChannelDto): Promise<Channel> {\n    const username = this.parseUsername(dto.usernameOrLink);\n    \n    // Check for duplicates\n    const existing = await this.channelsRepository.findOne({ where: { username } });\n    if (existing) {\n      throw new ConflictException('Channel already exists');\n    }\n    \n    // TODO: Resolve channel via Telegram API (will be implemented in crawler module)\n    // For now, create with placeholder data\n    const channel = this.channelsRepository.create({\n      username,\n      telegramId: '0', // Will be updated by crawler\n      title: username,\n      topic: dto.topic,\n      channelType: dto.channelType,\n      crawlPriority: dto.crawlPriority || 5,\n      isActive: true,\n    });\n    \n    return this.channelsRepository.save(channel);\n  }\n\n  async findAll(filters?: {\n    topic?: string;\n    channelType?: string;\n    isActive?: boolean;\n  }): Promise<Channel[]> {\n    const query = this.channelsRepository.createQueryBuilder('channel');\n    \n    if (filters?.topic) {\n      query.andWhere('channel.topic = :topic', { topic: filters.topic });\n    }\n    if (filters?.channelType) {\n      query.andWhere('channel.channelType = :channelType', { channelType: filters.channelType });\n    }\n    if (filters?.isActive !== undefined) {\n      query.andWhere('channel.isActive = :isActive', { isActive: filters.isActive });\n    }\n    \n    return query\n      .orderBy('channel.title', 'ASC')\n      .getMany();\n  }\n\n  async findOne(id: string): Promise<Channel> {\n    const channel = await this.channelsRepository.findOne({ where: { id } });\n    if (!channel) throw new NotFoundException('Channel not found');\n    return channel;\n  }\n\n  async update(id: string, dto: UpdateChannelDto): Promise<Channel> {\n    const channel = await this.findOne(id);\n    Object.assign(channel, dto);\n    return this.channelsRepository.save(channel);\n  }\n\n  async remove(id: string): Promise<void> {\n    const channel = await this.findOne(id);\n    // Soft delete\n    channel.isActive = false;\n    await this.channelsRepository.save(channel);\n  }\n\n  async refreshMetadata(id: string): Promise<Channel> {\n    const channel = await this.findOne(id);\n    // TODO: Implement Telegram API call to refresh metadata\n    // This will be completed in the crawler module\n    return channel;\n  }\n}\n```\n\n4. Create apps/api/src/modules/channels/channels.controller.ts:\n```typescript\nimport { Controller, Get, Post, Patch, Delete, Body, Param, Query, UseGuards, ParseUUIDPipe } from '@nestjs/common';\nimport { ChannelsService } from './channels.service';\nimport { CreateChannelDto } from './dto/create-channel.dto';\nimport { UpdateChannelDto } from './dto/update-channel.dto';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';\n\n@Controller('channels')\n@UseGuards(JwtAuthGuard)\nexport class ChannelsController {\n  constructor(private channelsService: ChannelsService) {}\n\n  @Post()\n  async create(@Body() dto: CreateChannelDto) {\n    return this.channelsService.create(dto);\n  }\n\n  @Get()\n  async findAll(\n    @Query('topic') topic?: string,\n    @Query('channelType') channelType?: string,\n    @Query('isActive') isActive?: string,\n  ) {\n    return this.channelsService.findAll({\n      topic,\n      channelType,\n      isActive: isActive ? isActive === 'true' : undefined,\n    });\n  }\n\n  @Get(':id')\n  async findOne(@Param('id', ParseUUIDPipe) id: string) {\n    return this.channelsService.findOne(id);\n  }\n\n  @Patch(':id')\n  async update(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Body() dto: UpdateChannelDto,\n  ) {\n    return this.channelsService.update(id, dto);\n  }\n\n  @Delete(':id')\n  async remove(@Param('id', ParseUUIDPipe) id: string) {\n    await this.channelsService.remove(id);\n    return { message: 'Channel removed successfully' };\n  }\n\n  @Post(':id/refresh')\n  async refresh(@Param('id', ParseUUIDPipe) id: string) {\n    return this.channelsService.refreshMetadata(id);\n  }\n}\n```\n\n5. Create apps/api/src/modules/channels/channels.module.ts:\n```typescript\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { Channel } from '../../database/entities/channel.entity';\nimport { ChannelsService } from './channels.service';\nimport { ChannelsController } from './channels.controller';\nimport { AuthModule } from '../auth/auth.module';\n\n@Module({\n  imports: [\n    TypeOrmModule.forFeature([Channel]),\n    AuthModule,\n  ],\n  providers: [ChannelsService],\n  controllers: [ChannelsController],\n  exports: [ChannelsService],\n})\nexport class ChannelsModule {}\n```",
        "testStrategy": "1. Unit tests for ChannelsService:\n   - parseUsername handles @username, t.me/username, https://t.me/username\n   - create throws ConflictException for duplicate usernames\n   - findAll applies filters correctly\n   - update modifies only provided fields\n   - remove performs soft delete (sets isActive=false)\n2. Integration tests for ChannelsController:\n   - POST /channels creates channel with valid data\n   - GET /channels returns filtered results\n   - GET /channels/:id returns channel details\n   - PATCH /channels/:id updates channel\n   - DELETE /channels/:id soft deletes channel\n   - POST /channels/:id/refresh returns channel (metadata refresh pending)\n3. Test authentication guard blocks unauthenticated requests\n4. Test validation with invalid DTOs (wrong enum values, invalid username format)\n5. E2E test: create channel -> list channels -> update -> soft delete -> verify not in active list",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Expand into: 1) Create DTOs with validation for create/update operations, 2) Implement username parsing utility (handles @username, t.me links), 3) Build ChannelsService with CRUD operations, 4) Add filtering and query building logic, 5) Create ChannelsController with auth guards, 6) Implement soft delete mechanism, 7) Write tests for username parsing and filter combinations"
      },
      {
        "id": "6",
        "title": "Implement Posts Module with Feed and Search",
        "description": "Create posts endpoints with unified feed, filtering by date/topic, pagination, full-text search with PostgreSQL tsvector, and search result highlighting.",
        "details": "1. Create apps/api/src/modules/posts/dto/feed-query.dto.ts:\n```typescript\nimport { IsOptional, IsUUID, IsDateString, IsInt, Min, Max, IsIn } from 'class-validator';\nimport { Type } from 'class-transformer';\n\nexport class FeedQueryDto {\n  @IsOptional()\n  @IsUUID()\n  channelId?: string;\n\n  @IsOptional()\n  @IsDateString()\n  dateFrom?: string;\n\n  @IsOptional()\n  @IsDateString()\n  dateTo?: string;\n\n  @IsOptional()\n  topic?: string;\n\n  @IsOptional()\n  @IsIn(['date', 'views', 'forwards'])\n  sort?: 'date' | 'views' | 'forwards';\n\n  @IsOptional()\n  @IsIn(['asc', 'desc'])\n  order?: 'asc' | 'desc';\n\n  @IsOptional()\n  @Type(() => Number)\n  @IsInt()\n  @Min(1)\n  page?: number;\n\n  @IsOptional()\n  @Type(() => Number)\n  @IsInt()\n  @Min(1)\n  @Max(100)\n  limit?: number;\n}\n```\n\n2. Create apps/api/src/modules/posts/dto/search-query.dto.ts:\n```typescript\nimport { IsString, IsOptional, IsDateString, IsInt, Min, Max } from 'class-validator';\nimport { Type } from 'class-transformer';\n\nexport class SearchQueryDto {\n  @IsString()\n  q: string;\n\n  @IsOptional()\n  @IsDateString()\n  dateFrom?: string;\n\n  @IsOptional()\n  @IsDateString()\n  dateTo?: string;\n\n  @IsOptional()\n  topic?: string;\n\n  @IsOptional()\n  @Type(() => Number)\n  @IsInt()\n  @Min(1)\n  page?: number;\n\n  @IsOptional()\n  @Type(() => Number)\n  @IsInt()\n  @Min(1)\n  @Max(100)\n  limit?: number;\n}\n```\n\n3. Create apps/api/src/modules/posts/posts.service.ts:\n```typescript\nimport { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Post } from '../../database/entities/post.entity';\nimport { Channel } from '../../database/entities/channel.entity';\nimport { FeedQueryDto } from './dto/feed-query.dto';\nimport { SearchQueryDto } from './dto/search-query.dto';\n\n@Injectable()\nexport class PostsService {\n  constructor(\n    @InjectRepository(Post)\n    private postsRepository: Repository<Post>,\n    @InjectRepository(Channel)\n    private channelsRepository: Repository<Channel>,\n  ) {}\n\n  async getFeed(query: FeedQueryDto) {\n    const page = query.page || 1;\n    const limit = query.limit || 20;\n    const skip = (page - 1) * limit;\n    const sort = query.sort || 'date';\n    const order = query.order || 'desc';\n\n    const qb = this.postsRepository\n      .createQueryBuilder('post')\n      .leftJoinAndSelect('post.channel', 'channel')\n      .where('post.isDeleted = :isDeleted', { isDeleted: false })\n      .andWhere('channel.isActive = :isActive', { isActive: true });\n\n    // Apply filters\n    if (query.channelId) {\n      qb.andWhere('post.channelId = :channelId', { channelId: query.channelId });\n    }\n\n    if (query.topic) {\n      qb.andWhere('channel.topic = :topic', { topic: query.topic });\n    }\n\n    if (query.dateFrom) {\n      qb.andWhere('post.postedAt >= :dateFrom', { dateFrom: query.dateFrom });\n    }\n\n    if (query.dateTo) {\n      qb.andWhere('post.postedAt <= :dateTo', { dateTo: query.dateTo });\n    }\n\n    // Apply sorting\n    const sortField = sort === 'date' ? 'post.postedAt' : `post.${sort}`;\n    qb.orderBy(sortField, order.toUpperCase() as 'ASC' | 'DESC');\n\n    // Get total count and results\n    const [posts, total] = await qb\n      .skip(skip)\n      .take(limit)\n      .getManyAndCount();\n\n    return {\n      data: posts,\n      meta: {\n        total,\n        page,\n        limit,\n        totalPages: Math.ceil(total / limit),\n      },\n    };\n  }\n\n  async search(query: SearchQueryDto) {\n    const page = query.page || 1;\n    const limit = query.limit || 20;\n    const skip = (page - 1) * limit;\n\n    // Sanitize search query for PostgreSQL\n    const searchTerm = query.q.replace(/[^\\w\\s]/g, ' ').trim().split(/\\s+/).join(' & ');\n\n    let qb = this.postsRepository\n      .createQueryBuilder('post')\n      .leftJoinAndSelect('post.channel', 'channel')\n      .where('post.isDeleted = :isDeleted', { isDeleted: false })\n      .andWhere('channel.isActive = :isActive', { isActive: true })\n      .andWhere('post.search_vector @@ to_tsquery(:searchTerm)', { searchTerm });\n\n    // Apply additional filters\n    if (query.topic) {\n      qb.andWhere('channel.topic = :topic', { topic: query.topic });\n    }\n\n    if (query.dateFrom) {\n      qb.andWhere('post.postedAt >= :dateFrom', { dateFrom: query.dateFrom });\n    }\n\n    if (query.dateTo) {\n      qb.andWhere('post.postedAt <= :dateTo', { dateTo: query.dateTo });\n    }\n\n    // Add ranking and highlighting\n    qb = qb\n      .addSelect(\n        'ts_rank(post.search_vector, to_tsquery(:searchTerm))',\n        'rank',\n      )\n      .addSelect(\n        `ts_headline('english', post.text_content, to_tsquery(:searchTerm), 'MaxWords=50, MinWords=20, StartSel=<mark>, StopSel=</mark>')`,\n        'highlight',\n      )\n      .orderBy('rank', 'DESC');\n\n    const [posts, total] = await qb\n      .skip(skip)\n      .take(limit)\n      .getManyAndCount();\n\n    // Map results to include highlights\n    const results = posts.map((post: any) => ({\n      ...post,\n      highlight: post.highlight,\n    }));\n\n    return {\n      data: results,\n      meta: {\n        total,\n        page,\n        limit,\n        totalPages: Math.ceil(total / limit),\n        query: query.q,\n      },\n    };\n  }\n\n  async findOne(id: string): Promise<Post> {\n    const post = await this.postsRepository.findOne({\n      where: { id },\n      relations: ['channel'],\n    });\n    if (!post) throw new NotFoundException('Post not found');\n    return post;\n  }\n\n  async getMediaUrl(id: string): Promise<{ mediaFileId: string; mediaType: string }> {\n    const post = await this.findOne(id);\n    if (!post.hasMedia || !post.mediaFileId) {\n      throw new NotFoundException('Post has no media');\n    }\n    return {\n      mediaFileId: post.mediaFileId,\n      mediaType: post.mediaType || 'photo',\n    };\n  }\n}\n```\n\n4. Create apps/api/src/modules/posts/posts.controller.ts:\n```typescript\nimport { Controller, Get, Param, Query, UseGuards, ParseUUIDPipe } from '@nestjs/common';\nimport { PostsService } from './posts.service';\nimport { FeedQueryDto } from './dto/feed-query.dto';\nimport { SearchQueryDto } from './dto/search-query.dto';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';\n\n@Controller('posts')\n@UseGuards(JwtAuthGuard)\nexport class PostsController {\n  constructor(private postsService: PostsService) {}\n\n  @Get()\n  async getFeed(@Query() query: FeedQueryDto) {\n    return this.postsService.getFeed(query);\n  }\n\n  @Get('search')\n  async search(@Query() query: SearchQueryDto) {\n    return this.postsService.search(query);\n  }\n\n  @Get(':id')\n  async findOne(@Param('id', ParseUUIDPipe) id: string) {\n    return this.postsService.findOne(id);\n  }\n\n  @Get(':id/media')\n  async getMedia(@Param('id', ParseUUIDPipe) id: string) {\n    return this.postsService.getMediaUrl(id);\n  }\n}\n```\n\n5. Create apps/api/src/modules/posts/posts.module.ts:\n```typescript\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { Post } from '../../database/entities/post.entity';\nimport { Channel } from '../../database/entities/channel.entity';\nimport { PostsService } from './posts.service';\nimport { PostsController } from './posts.controller';\nimport { AuthModule } from '../auth/auth.module';\n\n@Module({\n  imports: [\n    TypeOrmModule.forFeature([Post, Channel]),\n    AuthModule,\n  ],\n  providers: [PostsService],\n  controllers: [PostsController],\n  exports: [PostsService],\n})\nexport class PostsModule {}\n```\n\n6. Update apps/api/src/app.module.ts to import new modules:\n```typescript\nimport { AuthModule } from './modules/auth/auth.module';\nimport { UsersModule } from './modules/users/users.module';\nimport { ChannelsModule } from './modules/channels/channels.module';\nimport { PostsModule } from './modules/posts/posts.module';\n\n@Module({\n  imports: [\n    // ... existing imports\n    AuthModule,\n    UsersModule,\n    ChannelsModule,\n    PostsModule,\n  ],\n})\n```",
        "testStrategy": "1. Unit tests for PostsService:\n   - getFeed applies all filter combinations correctly\n   - getFeed pagination works (page, limit, skip calculation)\n   - search sanitizes query and uses tsvector\n   - search ranking orders by relevance\n   - findOne returns post with channel relation\n   - getMediaUrl throws for posts without media\n2. Integration tests for PostsController:\n   - GET /posts returns paginated feed\n   - GET /posts?topic=tech filters by topic\n   - GET /posts?dateFrom=2025-01-01&dateTo=2025-01-31 filters by date range\n   - GET /posts/search?q=election returns ranked results\n   - GET /posts/search?q=climate&topic=news combines search with filters\n   - GET /posts/:id returns single post\n   - GET /posts/:id/media returns media file ID\n3. Test full-text search:\n   - Insert test posts with known content\n   - Search for terms and verify results contain those terms\n   - Verify highlights contain <mark> tags around matched terms\n4. Performance test: search across 10,000 posts completes in <2s\n5. E2E test: create posts -> search -> filter -> paginate",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Feed and Search Query DTOs with Validation",
            "description": "Implement FeedQueryDto and SearchQueryDto with comprehensive class-validator decorators for type safety, transformation, and input validation.",
            "dependencies": [],
            "details": "Create apps/api/src/modules/posts/dto/feed-query.dto.ts with optional filters (channelId, dateFrom, dateTo, topic, sort, order, page, limit) using @IsOptional, @IsUUID, @IsDateString, @IsIn, @Type transformers. Create apps/api/src/modules/posts/dto/search-query.dto.ts with required 'q' field and optional filters. Ensure proper validation decorators (@Min, @Max for pagination) and class-transformer @Type() for numeric fields.",
            "status": "pending",
            "testStrategy": "Unit tests: 1) Valid query objects pass validation, 2) Invalid UUIDs rejected, 3) Invalid date strings rejected, 4) Sort/order enum values enforced, 5) Page/limit numeric constraints work, 6) Type transformations convert strings to numbers correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Feed Service with Dynamic QueryBuilder",
            "description": "Build getFeed method in PostsService using TypeORM QueryBuilder with dynamic filtering by channelId, topic, date range, and sorting options.",
            "dependencies": [
              1
            ],
            "details": "Create PostsService in apps/api/src/modules/posts/posts.service.ts. Implement getFeed(query: FeedQueryDto) method that: 1) Creates QueryBuilder with leftJoinAndSelect for channel relation, 2) Applies base filters (isDeleted=false, isActive=true), 3) Conditionally adds WHERE clauses for channelId, topic, dateFrom, dateTo, 4) Implements dynamic sorting by date/views/forwards with asc/desc order, 5) Returns paginated results with metadata.",
            "status": "pending",
            "testStrategy": "Unit tests with mock repository: 1) Base query without filters returns all active posts, 2) channelId filter applies correctly, 3) topic filter works, 4) Date range filters (dateFrom, dateTo, both) work independently and together, 5) Each sort field (date, views, forwards) with each order (asc, desc) produces correct ORDER BY clause.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Search Query Sanitization for SQL Injection Prevention",
            "description": "Implement robust search query sanitization that converts user input to safe PostgreSQL tsquery format by removing special characters and preventing injection attacks.",
            "dependencies": [
              1
            ],
            "details": "In PostsService.search() method, sanitize the search query: 1) Use regex to strip non-alphanumeric characters except whitespace: query.q.replace(/[^\\w\\s]/g, ' '), 2) Trim and split on whitespace, 3) Join terms with ' & ' operator for AND logic in tsquery, 4) Pass sanitized term to parameterized query to prevent SQL injection. Document the sanitization logic clearly.",
            "status": "pending",
            "testStrategy": "Unit tests: 1) Simple query 'hello world' becomes 'hello & world', 2) Special chars in 'test@#$query' are stripped, 3) Multiple spaces normalized, 4) SQL injection attempts like \"'; DROP TABLE--\" are neutralized, 5) Unicode and emoji characters handled safely.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build Full-Text Search with PostgreSQL tsvector Queries",
            "description": "Implement search method using PostgreSQL full-text search with tsvector column and to_tsquery for matching against sanitized search terms.",
            "dependencies": [
              3
            ],
            "details": "In PostsService.search(query: SearchQueryDto): 1) Create QueryBuilder with channel join and base filters, 2) Add WHERE clause using 'post.search_vector @@ to_tsquery(:searchTerm)' with sanitized searchTerm parameter, 3) Apply optional filters (topic, dateFrom, dateTo) same as feed, 4) Use parameterized queries for all user inputs to prevent injection, 5) Return posts that match the full-text search criteria.",
            "status": "pending",
            "testStrategy": "Integration tests with test database: 1) Search finds posts containing exact term, 2) Multi-word search with AND logic works, 3) Search respects topic filter, 4) Search respects date range filters, 5) Search returns empty array when no matches, 6) Verify search_vector column is being queried correctly.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement ts_rank for Search Relevance Scoring",
            "description": "Add PostgreSQL ts_rank function to score search results by relevance and order results by rank in descending order.",
            "dependencies": [
              4
            ],
            "details": "In PostsService.search() QueryBuilder: 1) Use addSelect() to add 'ts_rank(post.search_vector, to_tsquery(:searchTerm))' as 'rank' column, 2) Add orderBy('rank', 'DESC') to sort by relevance score, 3) Ensure rank is calculated using same searchTerm as the WHERE clause, 4) Include rank in result mapping if needed for debugging or display.",
            "status": "pending",
            "testStrategy": "Integration tests: 1) Posts with more term occurrences rank higher, 2) Posts with terms in title rank higher than in body (if weighted), 3) Rank ordering is consistent and deterministic, 4) Verify SQL query includes ts_rank in SELECT and ORDER BY clauses.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create ts_headline for Search Result Highlighting",
            "description": "Implement PostgreSQL ts_headline to generate highlighted excerpts of matching text with <mark> tags around search terms.",
            "dependencies": [
              4
            ],
            "details": "In PostsService.search() QueryBuilder: 1) Use addSelect() to add ts_headline('english', post.text_content, to_tsquery(:searchTerm), 'MaxWords=50, MinWords=20, StartSel=<mark>, StopSel=</mark>') as 'highlight', 2) Map query results to include highlight field in response objects, 3) Configure headline options for readable excerpts (50 max words, 20 min words), 4) Use <mark> tags for frontend styling.",
            "status": "pending",
            "testStrategy": "Integration tests: 1) Highlighted text contains <mark> tags around search terms, 2) Excerpt length respects MaxWords constraint, 3) Highlight shows context around match, 4) Multiple term matches all highlighted, 5) Verify highlight field present in API response.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement Comprehensive Pagination Logic",
            "description": "Build pagination for both feed and search endpoints with page, limit, skip calculation, total count, and metadata response formatting.",
            "dependencies": [
              2,
              4
            ],
            "details": "For both getFeed() and search() methods: 1) Extract page (default 1) and limit (default 20) from query DTO, 2) Calculate skip = (page - 1) * limit, 3) Apply .skip(skip).take(limit) to QueryBuilder, 4) Use getManyAndCount() to get both results and total count, 5) Return response with data array and meta object containing { total, page, limit, totalPages: Math.ceil(total / limit) }, 6) For search, add query term to meta.",
            "status": "pending",
            "testStrategy": "Integration tests: 1) Page 1 returns first N items, 2) Page 2 skips first N items, 3) Limit parameter controls results per page, 4) totalPages calculation correct for various totals, 5) Last page returns remaining items even if less than limit, 6) Empty results return total=0 and empty data array.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Create PostsController with All REST Endpoints",
            "description": "Implement PostsController with GET /posts (feed), GET /posts/search, GET /posts/:id, and GET /posts/:id/media endpoints protected by JWT authentication.",
            "dependencies": [
              2,
              4,
              5,
              6,
              7
            ],
            "details": "Create apps/api/src/modules/posts/posts.controller.ts with: 1) @Controller('posts') and @UseGuards(JwtAuthGuard), 2) GET / endpoint using @Query() FeedQueryDto, 3) GET /search endpoint using @Query() SearchQueryDto, 4) GET /:id endpoint with @Param('id', ParseUUIDPipe), 5) GET /:id/media endpoint, 6) Implement findOne() and getMediaUrl() methods in service. Create PostsModule importing TypeOrmModule, AuthModule, and exporting PostsService.",
            "status": "pending",
            "testStrategy": "E2E tests: 1) GET /posts returns 200 with feed data, 2) GET /posts?channelId=uuid filters correctly, 3) GET /posts/search?q=term returns highlighted results, 4) GET /posts/:id returns single post, 5) GET /posts/invalid-uuid returns 400, 6) GET /posts/nonexistent-uuid returns 404, 7) Unauthenticated requests return 401, 8) GET /posts/:id/media returns media info or 404.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Write Performance Tests for Large Dataset Search",
            "description": "Create performance and load tests to validate search and feed performance with large datasets (10k+ posts), measure query execution time, and identify optimization opportunities.",
            "dependencies": [
              8
            ],
            "details": "Create performance test suite: 1) Seed test database with 10k-50k posts across multiple channels, 2) Test search query performance with various term combinations, 3) Measure ts_rank and ts_headline overhead, 4) Test pagination performance at different offsets, 5) Test feed with multiple filter combinations, 6) Verify query execution time <500ms for typical queries, 7) Use EXPLAIN ANALYZE to identify missing indexes, 8) Document performance benchmarks and recommendations.",
            "status": "pending",
            "testStrategy": "Performance benchmarks: 1) Search across 10k posts completes in <500ms, 2) Feed pagination remains fast at high page numbers, 3) Complex filter combinations don't degrade performance significantly, 4) GIN index on search_vector is being used (verify with EXPLAIN), 5) Database connection pool handles concurrent requests, 6) Memory usage stays stable under load.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 9,
        "expansionPrompt": "Divide into: 1) Create comprehensive query DTOs with validation and transformations, 2) Implement feed service with dynamic QueryBuilder, 3) Build full-text search with tsvector queries, 4) Add search query sanitization (prevent SQL injection), 5) Implement ts_rank for relevance scoring, 6) Create ts_headline for result highlighting, 7) Build pagination logic, 8) Create PostsController with all endpoints, 9) Write performance tests for search across large datasets"
      },
      {
        "id": "7",
        "title": "Set Up Telegram Crawler with GramJS and BullMQ",
        "description": "Implement Telegram integration using GramJS for MTProto communication, set up Redis with BullMQ for job queue, and create crawler service for channel resolution and post fetching with rate limit handling.",
        "details": "1. Install dependencies:\n```bash\ncd apps/api\npnpm add telegram bullmq ioredis sharp\npnpm add -D @types/sharp\n```\n\n2. Create apps/api/src/config/redis.config.ts:\n```typescript\nimport { registerAs } from '@nestjs/config';\n\nexport default registerAs('redis', () => ({\n  host: process.env.REDIS_HOST || 'localhost',\n  port: parseInt(process.env.REDIS_PORT || '6379'),\n  password: process.env.REDIS_PASSWORD,\n}));\n```\n\n3. Create apps/api/src/config/telegram.config.ts:\n```typescript\nimport { registerAs } from '@nestjs/config';\n\nexport default registerAs('telegram', () => ({\n  apiId: parseInt(process.env.TELEGRAM_API_ID || '0'),\n  apiHash: process.env.TELEGRAM_API_HASH || '',\n  sessionString: process.env.TELEGRAM_SESSION_STRING,\n  phoneNumber: process.env.TELEGRAM_PHONE_NUMBER,\n}));\n```\n\n4. Create apps/api/src/modules/crawler/telegram.service.ts:\n```typescript\nimport { Injectable, OnModuleInit, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { TelegramClient } from 'telegram';\nimport { StringSession } from 'telegram/sessions';\nimport { Api } from 'telegram/tl';\nimport * as input from 'telegram/client/inputs';\n\n@Injectable()\nexport class TelegramService implements OnModuleInit {\n  private client: TelegramClient;\n  private readonly logger = new Logger(TelegramService.name);\n\n  constructor(private configService: ConfigService) {}\n\n  async onModuleInit() {\n    const apiId = this.configService.get<number>('telegram.apiId');\n    const apiHash = this.configService.get<string>('telegram.apiHash');\n    const sessionString = this.configService.get<string>('telegram.sessionString') || '';\n\n    this.client = new TelegramClient(\n      new StringSession(sessionString),\n      apiId,\n      apiHash,\n      {\n        connectionRetries: 5,\n        requestRetries: 3,\n      },\n    );\n\n    await this.connect();\n  }\n\n  private async connect() {\n    try {\n      await this.client.connect();\n      this.logger.log('Telegram client connected');\n      \n      if (!await this.client.isUserAuthorized()) {\n        this.logger.warn('Telegram client not authorized. Please run authentication setup.');\n      }\n    } catch (error) {\n      this.logger.error('Failed to connect to Telegram', error);\n      throw error;\n    }\n  }\n\n  async resolveChannel(username: string): Promise<{\n    id: string;\n    title: string;\n    description?: string;\n    subscriberCount?: number;\n    photoUrl?: string;\n  }> {\n    try {\n      const entity = await this.client.getEntity(username);\n      \n      if (!(entity instanceof Api.Channel)) {\n        throw new Error('Entity is not a channel');\n      }\n\n      const fullChannel = await this.client.invoke(\n        new Api.channels.GetFullChannel({ channel: entity }),\n      );\n\n      return {\n        id: entity.id.toString(),\n        title: entity.title || username,\n        description: (fullChannel.fullChat as Api.ChannelFull).about,\n        subscriberCount: (fullChannel.fullChat as Api.ChannelFull).participantsCount,\n        photoUrl: undefined, // TODO: implement photo download\n      };\n    } catch (error) {\n      if (error.message?.includes('FLOOD_WAIT')) {\n        const waitTime = parseInt(error.message.match(/\\d+/)?.[0] || '60');\n        throw new Error(`FLOOD_WAIT_${waitTime}`);\n      }\n      throw error;\n    }\n  }\n\n  async fetchMessages(channelUsername: string, lastPostId?: string, limit = 100): Promise<any[]> {\n    try {\n      const entity = await this.client.getEntity(channelUsername);\n      \n      const messages = await this.client.getMessages(entity, {\n        limit,\n        minId: lastPostId ? parseInt(lastPostId) : undefined,\n      });\n\n      return messages.map(msg => this.parseMessage(msg));\n    } catch (error) {\n      if (error.message?.includes('FLOOD_WAIT')) {\n        const waitTime = parseInt(error.message.match(/\\d+/)?.[0] || '60');\n        throw new Error(`FLOOD_WAIT_${waitTime}`);\n      }\n      throw error;\n    }\n  }\n\n  private parseMessage(message: Api.Message): any {\n    if (!message || message.id === undefined) return null;\n\n    let mediaType: 'photo' | 'video' | 'document' | undefined;\n    let mediaFileId: string | undefined;\n\n    if (message.media) {\n      if (message.media instanceof Api.MessageMediaPhoto) {\n        mediaType = 'photo';\n        mediaFileId = (message.media.photo as Api.Photo)?.id?.toString();\n      } else if (message.media instanceof Api.MessageMediaDocument) {\n        const doc = message.media.document as Api.Document;\n        if (doc.mimeType?.startsWith('video/')) {\n          mediaType = 'video';\n        } else {\n          mediaType = 'document';\n        }\n        mediaFileId = doc.id?.toString();\n      }\n    }\n\n    return {\n      telegramPostId: message.id.toString(),\n      textContent: message.message || null,\n      hasMedia: !!message.media,\n      mediaType,\n      mediaFileId,\n      views: message.views,\n      forwards: message.forwards,\n      postedAt: new Date(message.date * 1000),\n      isEdited: !!message.editDate,\n      editedAt: message.editDate ? new Date(message.editDate * 1000) : null,\n    };\n  }\n\n  async downloadMedia(fileId: string, mediaType: 'photo' | 'video' | 'document'): Promise<Buffer> {\n    // TODO: Implement media download using file_id\n    // This requires accessing the message that contains the media\n    throw new Error('Media download not implemented yet');\n  }\n}\n```\n\n5. Create apps/api/src/modules/crawler/jobs/crawl-channel.job.ts:\n```typescript\nimport { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';\nimport { Job } from 'bullmq';\nimport { Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { TelegramService } from '../telegram.service';\nimport { Channel } from '../../../database/entities/channel.entity';\nimport { Post } from '../../../database/entities/post.entity';\n\ninterface CrawlChannelData {\n  channelId: string;\n}\n\n@Processor('crawl', { concurrency: 2 })\nexport class CrawlChannelProcessor extends WorkerHost {\n  private readonly logger = new Logger(CrawlChannelProcessor.name);\n\n  constructor(\n    private telegramService: TelegramService,\n    @InjectRepository(Channel)\n    private channelsRepository: Repository<Channel>,\n    @InjectRepository(Post)\n    private postsRepository: Repository<Post>,\n  ) {\n    super();\n  }\n\n  async process(job: Job<CrawlChannelData>): Promise<any> {\n    const { channelId } = job.data;\n    this.logger.log(`Processing crawl job for channel ${channelId}`);\n\n    try {\n      const channel = await this.channelsRepository.findOne({ where: { id: channelId } });\n      if (!channel || !channel.isActive) {\n        this.logger.warn(`Channel ${channelId} not found or inactive`);\n        return;\n      }\n\n      // If telegramId is 0, resolve channel first\n      if (channel.telegramId === '0') {\n        const metadata = await this.telegramService.resolveChannel(channel.username!);\n        channel.telegramId = metadata.id;\n        channel.title = metadata.title;\n        channel.description = metadata.description;\n        channel.subscriberCount = metadata.subscriberCount;\n        await this.channelsRepository.save(channel);\n      }\n\n      // Fetch new messages\n      const messages = await this.telegramService.fetchMessages(\n        channel.username!,\n        channel.lastPostId,\n        100,\n      );\n\n      this.logger.log(`Fetched ${messages.length} messages for channel ${channel.username}`);\n\n      // Save posts\n      for (const msg of messages.filter(m => m !== null)) {\n        const existing = await this.postsRepository.findOne({\n          where: {\n            channelId: channel.id,\n            telegramPostId: msg.telegramPostId,\n          },\n        });\n\n        if (existing) {\n          // Update if edited\n          if (msg.isEdited) {\n            Object.assign(existing, msg);\n            await this.postsRepository.save(existing);\n          }\n        } else {\n          // Create new post\n          const post = this.postsRepository.create({\n            ...msg,\n            channelId: channel.id,\n          });\n          await this.postsRepository.save(post);\n        }\n      }\n\n      // Update channel last crawl info\n      if (messages.length > 0) {\n        const maxPostId = Math.max(...messages.map(m => parseInt(m.telegramPostId)));\n        channel.lastPostId = maxPostId.toString();\n      }\n      channel.lastCrawledAt = new Date();\n      await this.channelsRepository.save(channel);\n\n      return { messageCount: messages.length };\n    } catch (error) {\n      if (error.message?.startsWith('FLOOD_WAIT_')) {\n        const waitTime = parseInt(error.message.split('_')[2]);\n        this.logger.warn(`FLOOD_WAIT: Retrying in ${waitTime} seconds`);\n        throw new Error(`Rate limited, retry after ${waitTime}s`);\n      }\n      throw error;\n    }\n  }\n\n  @OnWorkerEvent('failed')\n  onFailed(job: Job, error: Error) {\n    this.logger.error(`Job ${job.id} failed:`, error);\n  }\n}\n```\n\n6. Create apps/api/src/modules/crawler/crawler.module.ts:\n```typescript\nimport { Module } from '@nestjs/common';\nimport { BullModule } from '@nestjs/bullmq';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport redisConfig from '../../config/redis.config';\nimport telegramConfig from '../../config/telegram.config';\nimport { Channel } from '../../database/entities/channel.entity';\nimport { Post } from '../../database/entities/post.entity';\nimport { TelegramService } from './telegram.service';\nimport { CrawlChannelProcessor } from './jobs/crawl-channel.job';\nimport { CrawlerService } from './crawler.service';\n\n@Module({\n  imports: [\n    ConfigModule.forFeature(redisConfig),\n    ConfigModule.forFeature(telegramConfig),\n    TypeOrmModule.forFeature([Channel, Post]),\n    BullModule.forRootAsync({\n      inject: [ConfigService],\n      useFactory: (config: ConfigService) => ({\n        connection: {\n          host: config.get('redis.host'),\n          port: config.get('redis.port'),\n          password: config.get('redis.password'),\n        },\n      }),\n    }),\n    BullModule.registerQueue({ name: 'crawl' }),\n  ],\n  providers: [TelegramService, CrawlChannelProcessor, CrawlerService],\n  exports: [CrawlerService, TelegramService],\n})\nexport class CrawlerModule {}\n```\n\n7. Create apps/api/src/modules/crawler/crawler.service.ts:\n```typescript\nimport { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { InjectQueue } from '@nestjs/bullmq';\nimport { Queue } from 'bullmq';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Channel } from '../../database/entities/channel.entity';\nimport { Cron, CronExpression } from '@nestjs/schedule';\n\n@Injectable()\nexport class CrawlerService implements OnModuleInit {\n  private readonly logger = new Logger(CrawlerService.name);\n\n  constructor(\n    @InjectQueue('crawl') private crawlQueue: Queue,\n    @InjectRepository(Channel)\n    private channelsRepository: Repository<Channel>,\n  ) {}\n\n  async onModuleInit() {\n    // Queue initial crawl for all active channels\n    await this.queueActiveChannels();\n  }\n\n  @Cron(CronExpression.EVERY_30_MINUTES)\n  async scheduledCrawl() {\n    this.logger.log('Running scheduled crawl');\n    await this.queueActiveChannels();\n  }\n\n  async queueActiveChannels() {\n    const channels = await this.channelsRepository.find({\n      where: { isActive: true },\n    });\n\n    for (const channel of channels) {\n      await this.queueChannelCrawl(channel.id);\n    }\n\n    this.logger.log(`Queued ${channels.length} channels for crawling`);\n  }\n\n  async queueChannelCrawl(channelId: string) {\n    await this.crawlQueue.add(\n      'crawl-channel',\n      { channelId },\n      {\n        attempts: 3,\n        backoff: {\n          type: 'exponential',\n          delay: 60000, // 1 minute\n        },\n      },\n    );\n  }\n}\n```\n\n8. Install @nestjs/schedule:\n```bash\npnpm add @nestjs/schedule\n```\n\n9. Update .env.example:\n```\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=\nTELEGRAM_API_ID=your_api_id\nTELEGRAM_API_HASH=your_api_hash\nTELEGRAM_SESSION_STRING=\nTELEGRAM_PHONE_NUMBER=\n```",
        "testStrategy": "1. Unit tests for TelegramService:\n   - resolveChannel returns channel metadata for valid username\n   - resolveChannel throws for invalid username\n   - fetchMessages returns parsed messages\n   - parseMessage extracts text, media type, and metadata correctly\n   - FLOOD_WAIT errors are caught and re-thrown with wait time\n2. Unit tests for CrawlChannelProcessor:\n   - process resolves channel if telegramId is 0\n   - process saves new posts to database\n   - process updates edited posts\n   - process handles FLOOD_WAIT with exponential backoff\n3. Integration test:\n   - Mock TelegramClient\n   - Queue crawl job with test channel\n   - Verify posts saved to database\n4. Test CrawlerService scheduled job:\n   - Verify cron runs every 30 minutes\n   - Verify all active channels queued\n5. E2E test with real Telegram API (using test channel):\n   - Add channel -> crawl job executes -> posts appear in database\n6. Test rate limit handling with multiple rapid crawls",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Redis, BullMQ, GramJS and dependencies",
            "description": "Install telegram, bullmq, ioredis, sharp packages and their TypeScript type definitions for Telegram crawler functionality.",
            "dependencies": [],
            "details": "Run `cd apps/api && pnpm add telegram bullmq ioredis sharp && pnpm add -D @types/sharp` to install GramJS client library, BullMQ job queue, Redis client, and image processing library. Also install @nestjs/schedule with `pnpm add @nestjs/schedule` for cron job scheduling.",
            "status": "pending",
            "testStrategy": "Verify all packages are listed in package.json dependencies and node_modules folder contains the installed packages. Check that TypeScript can resolve the type definitions.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Redis and Telegram configuration modules",
            "description": "Set up configuration files for Redis connection and Telegram API credentials using NestJS ConfigModule.",
            "dependencies": [
              1
            ],
            "details": "Create apps/api/src/config/redis.config.ts with registerAs('redis') exporting host, port, and password from environment variables. Create apps/api/src/config/telegram.config.ts with registerAs('telegram') exporting apiId, apiHash, sessionString, and phoneNumber. Update .env.example with REDIS_HOST, REDIS_PORT, REDIS_PASSWORD, TELEGRAM_API_ID, TELEGRAM_API_HASH, TELEGRAM_SESSION_STRING, and TELEGRAM_PHONE_NUMBER.",
            "status": "pending",
            "testStrategy": "Unit test both config modules to verify they return correct values when environment variables are set. Test default values for optional fields like redis host and port.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement TelegramService with GramJS client initialization",
            "description": "Create TelegramService with TelegramClient setup, connection handling, and session management using StringSession.",
            "dependencies": [
              2
            ],
            "details": "Create apps/api/src/modules/crawler/telegram.service.ts with @Injectable decorator. Inject ConfigService, initialize TelegramClient in onModuleInit with apiId, apiHash, and StringSession. Implement connect() method with connection retry logic (connectionRetries: 5, requestRetries: 3). Add authorization check and log warning if user not authorized. Handle connection errors and log appropriately.",
            "status": "pending",
            "testStrategy": "Unit test TelegramService initialization with mocked ConfigService. Verify client.connect() is called during onModuleInit. Test error handling when connection fails. Mock isUserAuthorized() to verify authorization check logging.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement channel resolution with metadata extraction",
            "description": "Build resolveChannel method to fetch Telegram channel metadata including ID, title, description, and subscriber count.",
            "dependencies": [
              3
            ],
            "details": "In TelegramService, implement resolveChannel(username: string) that calls client.getEntity(username), validates it's a Channel instance, invokes channels.GetFullChannel API, and returns object with id, title, description, subscriberCount, and photoUrl (undefined for now). Handle errors and check for FLOOD_WAIT in error message, extracting wait time with regex and throwing formatted error.",
            "status": "pending",
            "testStrategy": "Unit test resolveChannel with mocked TelegramClient.getEntity and invoke methods. Test with valid channel returns metadata. Test with non-channel entity throws error. Test FLOOD_WAIT error parsing and re-throwing with correct wait time format.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build message fetching with pagination support",
            "description": "Implement fetchMessages method to retrieve channel posts with limit and offset based on lastPostId.",
            "dependencies": [
              3
            ],
            "details": "In TelegramService, implement fetchMessages(channelUsername: string, lastPostId?: string, limit = 100) that calls client.getEntity(channelUsername), then client.getMessages with limit and minId (parsed from lastPostId if provided). Map returned messages through parseMessage helper. Handle FLOOD_WAIT errors same as resolveChannel method.",
            "status": "pending",
            "testStrategy": "Unit test fetchMessages with mocked client.getMessages. Verify limit parameter is passed correctly. Test minId is set when lastPostId is provided. Test pagination by verifying minId is parsed as integer. Test FLOOD_WAIT error handling.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create message parser for text and media extraction",
            "description": "Implement parseMessage helper to extract post content, media type, metadata, and statistics from Telegram Api.Message objects.",
            "dependencies": [
              5
            ],
            "details": "In TelegramService, implement private parseMessage(message: Api.Message) that returns null for invalid messages. Extract telegramPostId, textContent (message.message), check hasMedia presence. Detect mediaType (photo/video/document) by checking MessageMediaPhoto and MessageMediaDocument with mimeType. Extract mediaFileId from photo.id or document.id. Include views, forwards, postedAt (convert Unix timestamp), isEdited flag, and editedAt date.",
            "status": "pending",
            "testStrategy": "Unit test parseMessage with various message types: text-only, photo, video, document. Verify null is returned for undefined message. Test date conversion from Unix timestamp. Test media type detection for different Api.MessageMedia types. Verify all fields are correctly extracted.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement FLOOD_WAIT error detection and formatting",
            "description": "Add comprehensive FLOOD_WAIT error handling across all Telegram API methods with wait time extraction.",
            "dependencies": [
              4,
              5
            ],
            "details": "In TelegramService resolveChannel and fetchMessages methods, wrap API calls in try-catch. Check if error.message includes 'FLOOD_WAIT' string. Use regex /\\d+/ to extract wait time in seconds from error message. Throw new Error with format 'FLOOD_WAIT_{waitTime}' to be handled by job processor. Default to 60 seconds if regex match fails.",
            "status": "pending",
            "testStrategy": "Unit test error handling by mocking TelegramClient to throw FLOOD_WAIT errors with various formats. Verify wait time extraction regex works for different messages like 'FLOOD_WAIT_123'. Test default 60s fallback. Verify error is re-thrown in correct format.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Create CrawlChannelProcessor with BullMQ job logic",
            "description": "Build BullMQ worker processor to handle channel crawling jobs with Telegram API calls and database persistence.",
            "dependencies": [
              6,
              7
            ],
            "details": "Create apps/api/src/modules/crawler/jobs/crawl-channel.job.ts with @Processor('crawl', { concurrency: 2 }) decorator extending WorkerHost. Inject TelegramService and TypeORM repositories for Channel and Post. Implement process(job: Job<CrawlChannelData>) that loads channel from DB, checks isActive flag, resolves channel if telegramId is '0', fetches messages, and returns message count. Add @OnWorkerEvent('failed') handler to log errors.",
            "status": "pending",
            "testStrategy": "Unit test CrawlChannelProcessor.process with mocked TelegramService and repositories. Test inactive channel early return. Test channel resolution when telegramId is '0'. Test message fetching is called with correct parameters. Mock FLOOD_WAIT error and verify it's re-thrown.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement incremental crawling and post deduplication",
            "description": "Add logic to fetch only new posts using lastPostId and handle post updates for edited messages.",
            "dependencies": [
              8
            ],
            "details": "In CrawlChannelProcessor.process, pass channel.lastPostId to fetchMessages for incremental crawling. Loop through returned messages and check if post exists using findOne with channelId and telegramPostId. For existing posts, check isEdited flag and update with Object.assign and save if edited. For new posts, create using postsRepository.create and save. After processing, update channel.lastPostId to max telegramPostId from fetched messages and set channel.lastCrawledAt to current date.",
            "status": "pending",
            "testStrategy": "Unit test incremental logic with mocked repository.findOne. Test new post creation flow. Test existing post update when isEdited is true. Test existing post is skipped when not edited. Verify channel.lastPostId is set to maximum post ID. Test lastCrawledAt is updated.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Build CrawlerService with cron scheduling",
            "description": "Create CrawlerService to manage job queue and schedule periodic crawls every 30 minutes using @nestjs/schedule.",
            "dependencies": [
              8
            ],
            "details": "Create apps/api/src/modules/crawler/crawler.service.ts with @Injectable decorator. Inject @InjectQueue('crawl') Queue and Channel repository. Implement onModuleInit to call queueActiveChannels on startup. Add @Cron(CronExpression.EVERY_30_MINUTES) decorator on scheduledCrawl method. Implement queueActiveChannels to find all channels with isActive=true and call queueChannelCrawl for each. Implement queueChannelCrawl to add job with attempts: 3 and exponential backoff with 60s delay.",
            "status": "pending",
            "testStrategy": "Unit test CrawlerService with mocked Queue and repository. Test onModuleInit calls queueActiveChannels. Test scheduledCrawl is decorated with cron expression. Mock repository.find to return test channels and verify queueChannelCrawl is called for each. Test job options include correct attempts and backoff configuration.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Set up CrawlerModule with BullMQ and TypeORM configuration",
            "description": "Create NestJS module wiring together Redis, BullMQ queue, TypeORM entities, and crawler services.",
            "dependencies": [
              9,
              10
            ],
            "details": "Create apps/api/src/modules/crawler/crawler.module.ts with @Module decorator. Import ConfigModule.forFeature for redis and telegram configs, TypeOrmModule.forFeature([Channel, Post]), BullModule.forRootAsync with Redis connection from ConfigService, and BullModule.registerQueue({ name: 'crawl' }). Add TelegramService, CrawlChannelProcessor, and CrawlerService to providers. Export CrawlerService and TelegramService for use in other modules.",
            "status": "pending",
            "testStrategy": "Integration test module imports by creating NestJS testing module. Verify TelegramService, CrawlerService, and CrawlChannelProcessor can be resolved from module. Test BullModule is configured with correct Redis connection. Verify TypeORM entities are registered.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Write integration tests with mocked Telegram client",
            "description": "Create comprehensive integration tests for crawler flow using mocked TelegramClient to simulate API responses.",
            "dependencies": [
              11
            ],
            "details": "Create test file apps/api/src/modules/crawler/crawler.integration.spec.ts. Mock TelegramClient.connect, getEntity, invoke, and getMessages methods. Create test scenarios: 1) Full crawl of new channel with resolution, 2) Incremental crawl with lastPostId, 3) FLOOD_WAIT handling and job retry, 4) Post deduplication and updates, 5) Cron scheduling triggers jobs. Use in-memory SQLite database for TypeORM. Verify job queue operations and database state after each scenario.",
            "status": "pending",
            "testStrategy": "Run integration tests with npm test. Verify all test scenarios pass. Check code coverage for crawler module exceeds 80%. Test with various message types (text, photo, video). Verify FLOOD_WAIT retry logic works end-to-end.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 12,
        "expansionPrompt": "Break down into: 1) Set up Redis and BullMQ configuration, 2) Configure GramJS TelegramClient with session management, 3) Implement channel resolution logic, 4) Build message fetching with pagination, 5) Create message parser for text/media extraction, 6) Implement FLOOD_WAIT error handling with exponential backoff, 7) Create CrawlChannelProcessor with job logic, 8) Build incremental crawling (fetch only new posts), 9) Implement post deduplication and update logic, 10) Create CrawlerService with cron scheduling, 11) Add job retry mechanism, 12) Write integration tests with mocked Telegram client"
      },
      {
        "id": "8",
        "title": "Initialize Nuxt 4 Frontend with FSD Architecture",
        "description": "Set up Nuxt 4 application with Feature-Sliced Design structure, Nuxt UI v3, Tailwind CSS 4, Pinia for state management, and configure API client with JWT interceptors.",
        "details": "1. Initialize Nuxt 4 in apps/web:\n```bash\ncd apps/web\npnpx nuxi@latest init . --package-manager pnpm\n```\n\n2. Install dependencies:\n```bash\npnpm add @nuxt/ui pinia @pinia/nuxt @vueuse/core\npnpm add -D @nuxtjs/tailwindcss\n```\n\n3. Update apps/web/nuxt.config.ts:\n```typescript\nexport default defineNuxtConfig({\n  devtools: { enabled: true },\n  modules: ['@nuxt/ui', '@pinia/nuxt'],\n  \n  runtimeConfig: {\n    public: {\n      apiBase: process.env.NUXT_PUBLIC_API_BASE || 'http://localhost:3001/api',\n    },\n  },\n\n  typescript: {\n    strict: true,\n    typeCheck: true,\n  },\n\n  compatibilityDate: '2025-01-01',\n});\n```\n\n4. Create FSD directory structure:\n```bash\nmkdir -p src/{app/{providers,styles},pages,widgets,features,entities,shared/{api,ui,lib,config}}\n```\n\n5. Create apps/web/src/shared/api/client.ts:\n```typescript\nimport type { AuthTokens } from '@telegram-crawler/types';\n\nclass ApiClient {\n  private baseURL: string;\n  private accessToken: string | null = null;\n  private refreshToken: string | null = null;\n\n  constructor(baseURL: string) {\n    this.baseURL = baseURL;\n    this.loadTokens();\n  }\n\n  private loadTokens() {\n    if (process.client) {\n      this.accessToken = sessionStorage.getItem('accessToken');\n      this.refreshToken = localStorage.getItem('refreshToken');\n    }\n  }\n\n  private saveTokens(tokens: AuthTokens) {\n    this.accessToken = tokens.accessToken;\n    this.refreshToken = tokens.refreshToken;\n    if (process.client) {\n      sessionStorage.setItem('accessToken', tokens.accessToken);\n      localStorage.setItem('refreshToken', tokens.refreshToken);\n    }\n  }\n\n  private clearTokens() {\n    this.accessToken = null;\n    this.refreshToken = null;\n    if (process.client) {\n      sessionStorage.removeItem('accessToken');\n      localStorage.removeItem('refreshToken');\n    }\n  }\n\n  async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const headers: HeadersInit = {\n      'Content-Type': 'application/json',\n      ...options.headers,\n    };\n\n    if (this.accessToken) {\n      headers.Authorization = `Bearer ${this.accessToken}`;\n    }\n\n    let response = await fetch(`${this.baseURL}${endpoint}`, {\n      ...options,\n      headers,\n    });\n\n    // Handle token refresh\n    if (response.status === 401 && this.refreshToken) {\n      const refreshed = await this.refreshAccessToken();\n      if (refreshed) {\n        headers.Authorization = `Bearer ${this.accessToken}`;\n        response = await fetch(`${this.baseURL}${endpoint}`, {\n          ...options,\n          headers,\n        });\n      }\n    }\n\n    if (!response.ok) {\n      const error = await response.json().catch(() => ({ message: 'Request failed' }));\n      throw new Error(error.message || 'Request failed');\n    }\n\n    return response.json();\n  }\n\n  private async refreshAccessToken(): Promise<boolean> {\n    try {\n      const tokens = await fetch(`${this.baseURL}/auth/refresh`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ refreshToken: this.refreshToken }),\n      }).then(r => r.json());\n\n      this.saveTokens(tokens);\n      return true;\n    } catch {\n      this.clearTokens();\n      if (process.client) {\n        window.location.href = '/auth/login';\n      }\n      return false;\n    }\n  }\n\n  async login(email: string, password: string): Promise<AuthTokens> {\n    const tokens = await this.request<AuthTokens>('/auth/login', {\n      method: 'POST',\n      body: JSON.stringify({ email, password }),\n    });\n    this.saveTokens(tokens);\n    return tokens;\n  }\n\n  async logout() {\n    if (this.refreshToken) {\n      await this.request('/auth/logout', {\n        method: 'POST',\n        body: JSON.stringify({ refreshToken: this.refreshToken }),\n      });\n    }\n    this.clearTokens();\n  }\n\n  isAuthenticated(): boolean {\n    return !!this.accessToken;\n  }\n}\n\nexport const createApiClient = () => {\n  const config = useRuntimeConfig();\n  return new ApiClient(config.public.apiBase);\n};\n\nexport const useApi = () => {\n  const nuxtApp = useNuxtApp();\n  if (!nuxtApp.$api) {\n    nuxtApp.$api = createApiClient();\n  }\n  return nuxtApp.$api as ApiClient;\n};\n```\n\n6. Create apps/web/src/app/providers/api.plugin.ts:\n```typescript\nimport { createApiClient } from '~/shared/api/client';\n\nexport default defineNuxtPlugin(() => {\n  const api = createApiClient();\n  \n  return {\n    provide: {\n      api,\n    },\n  };\n});\n```\n\n7. Create apps/web/src/shared/ui/components/UButton.vue (example shared component):\n```vue\n<template>\n  <UButton v-bind=\"$attrs\">\n    <slot />\n  </UButton>\n</template>\n\n<script setup lang=\"ts\">\n// Re-export Nuxt UI components for FSD shared layer\n</script>\n```\n\n8. Create apps/web/src/entities/user/model/store.ts:\n```typescript\nimport { defineStore } from 'pinia';\nimport type { User } from '@telegram-crawler/types';\n\nexport const useUserStore = defineStore('user', () => {\n  const user = ref<User | null>(null);\n  const isAuthenticated = computed(() => !!user.value);\n\n  const setUser = (newUser: User | null) => {\n    user.value = newUser;\n  };\n\n  const clearUser = () => {\n    user.value = null;\n  };\n\n  return {\n    user,\n    isAuthenticated,\n    setUser,\n    clearUser,\n  };\n});\n```\n\n9. Create apps/web/src/features/auth/api/index.ts:\n```typescript\nexport const authApi = {\n  async login(email: string, password: string) {\n    const api = useApi();\n    return api.login(email, password);\n  },\n\n  async logout() {\n    const api = useApi();\n    return api.logout();\n  },\n\n  async getCurrentUser() {\n    const api = useApi();\n    return api.request('/auth/me', { method: 'POST' });\n  },\n};\n```\n\n10. Create apps/web/src/app/middleware/auth.global.ts:\n```typescript\nexport default defineNuxtRouteMiddleware((to) => {\n  const api = useApi();\n  const publicRoutes = ['/auth/login', '/auth/register'];\n\n  if (!api.isAuthenticated() && !publicRoutes.includes(to.path)) {\n    return navigateTo('/auth/login');\n  }\n\n  if (api.isAuthenticated() && publicRoutes.includes(to.path)) {\n    return navigateTo('/');\n  }\n});\n```\n\n11. Update apps/web/package.json to use workspace types:\n```json\n{\n  \"dependencies\": {\n    \"@telegram-crawler/types\": \"workspace:*\"\n  }\n}\n```",
        "testStrategy": "1. Verify Nuxt dev server starts:\n```bash\npnpm dev\n```\n2. Test ApiClient:\n   - Unit test request method with mock fetch\n   - Unit test token refresh flow\n   - Unit test 401 handling and redirect\n   - Test saveTokens/clearTokens with localStorage mock\n3. Test auth middleware:\n   - Unauthenticated user redirected to /auth/login\n   - Authenticated user can access protected routes\n   - Authenticated user redirected from /auth/login to /\n4. Test useUserStore:\n   - setUser updates user state\n   - isAuthenticated computed property\n   - clearUser resets state\n5. Visual test: Verify Nuxt UI components render correctly\n6. E2E test: Navigate to / -> redirected to /auth/login",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Expand into: 1) Initialize Nuxt 4 with required modules (@nuxt/ui, Pinia), 2) Create FSD directory structure (app, pages, widgets, features, entities, shared), 3) Build API client with fetch wrapper, 4) Implement JWT token management (sessionStorage/localStorage), 5) Add automatic token refresh interceptor, 6) Create auth middleware for route protection, 7) Set up Pinia user store, 8) Configure TypeScript with workspace types import"
      },
      {
        "id": "9",
        "title": "Build Authentication UI and Channel Management Pages",
        "description": "Create login page with form validation, implement channel list widget with add/edit/delete functionality, and build unified feed widget with post cards and filters.",
        "details": "1. Create apps/web/src/pages/auth/login.vue:\n```vue\n<template>\n  <div class=\"min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900\">\n    <UCard class=\"w-full max-w-md\">\n      <template #header>\n        <h2 class=\"text-2xl font-bold text-center\">Telegram Channel Crawler</h2>\n      </template>\n\n      <form @submit.prevent=\"handleLogin\" class=\"space-y-4\">\n        <UFormGroup label=\"Email\" name=\"email\" :error=\"errors.email\">\n          <UInput\n            v-model=\"form.email\"\n            type=\"email\"\n            placeholder=\"your@email.com\"\n            required\n          />\n        </UFormGroup>\n\n        <UFormGroup label=\"Password\" name=\"password\" :error=\"errors.password\">\n          <UInput\n            v-model=\"form.password\"\n            type=\"password\"\n            placeholder=\"••••••••\"\n            required\n          />\n        </UFormGroup>\n\n        <UButton\n          type=\"submit\"\n          block\n          :loading=\"loading\"\n          :disabled=\"loading\"\n        >\n          Log In\n        </UButton>\n      </form>\n\n      <div v-if=\"errors.general\" class=\"mt-4\">\n        <UAlert color=\"red\" variant=\"soft\" :title=\"errors.general\" />\n      </div>\n    </UCard>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { authApi } from '~/features/auth/api';\nimport { useUserStore } from '~/entities/user/model/store';\n\nconst form = reactive({\n  email: '',\n  password: '',\n});\n\nconst errors = reactive({\n  email: '',\n  password: '',\n  general: '',\n});\n\nconst loading = ref(false);\nconst userStore = useUserStore();\n\nconst handleLogin = async () => {\n  loading.value = true;\n  errors.email = '';\n  errors.password = '';\n  errors.general = '';\n\n  try {\n    await authApi.login(form.email, form.password);\n    const user = await authApi.getCurrentUser();\n    userStore.setUser(user);\n    await navigateTo('/');\n  } catch (error: any) {\n    errors.general = error.message || 'Login failed';\n  } finally {\n    loading.value = false;\n  }\n};\n</script>\n```\n\n2. Create apps/web/src/entities/channel/api/index.ts:\n```typescript\nimport type { Channel } from '@telegram-crawler/types';\n\nexport const channelApi = {\n  async getAll(filters?: { topic?: string; channelType?: string; isActive?: boolean }) {\n    const api = useApi();\n    const params = new URLSearchParams();\n    if (filters?.topic) params.append('topic', filters.topic);\n    if (filters?.channelType) params.append('channelType', filters.channelType);\n    if (filters?.isActive !== undefined) params.append('isActive', String(filters.isActive));\n    \n    return api.request<Channel[]>(`/channels?${params.toString()}`);\n  },\n\n  async create(data: { usernameOrLink: string; topic: string; channelType: string }) {\n    const api = useApi();\n    return api.request<Channel>('/channels', {\n      method: 'POST',\n      body: JSON.stringify(data),\n    });\n  },\n\n  async update(id: string, data: Partial<Channel>) {\n    const api = useApi();\n    return api.request<Channel>(`/channels/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(data),\n    });\n  },\n\n  async delete(id: string) {\n    const api = useApi();\n    return api.request(`/channels/${id}`, { method: 'DELETE' });\n  },\n\n  async refresh(id: string) {\n    const api = useApi();\n    return api.request<Channel>(`/channels/${id}/refresh`, { method: 'POST' });\n  },\n};\n```\n\n3. Create apps/web/src/features/add-channel/ui/AddChannelModal.vue:\n```vue\n<template>\n  <UModal v-model=\"isOpen\">\n    <UCard>\n      <template #header>\n        <h3 class=\"text-lg font-semibold\">Add Channel</h3>\n      </template>\n\n      <form @submit.prevent=\"handleSubmit\" class=\"space-y-4\">\n        <UFormGroup label=\"Channel Username or Link\" name=\"usernameOrLink\">\n          <UInput\n            v-model=\"form.usernameOrLink\"\n            placeholder=\"@channel or t.me/channel\"\n            required\n          />\n        </UFormGroup>\n\n        <UFormGroup label=\"Topic\" name=\"topic\">\n          <UInput v-model=\"form.topic\" placeholder=\"Technology\" required />\n        </UFormGroup>\n\n        <UFormGroup label=\"Type\" name=\"channelType\">\n          <USelect\n            v-model=\"form.channelType\"\n            :options=\"['news', 'personal_blog', 'official']\"\n            required\n          />\n        </UFormGroup>\n\n        <div class=\"flex gap-2\">\n          <UButton type=\"submit\" :loading=\"loading\">Add Channel</UButton>\n          <UButton color=\"gray\" variant=\"ghost\" @click=\"isOpen = false\">Cancel</UButton>\n        </div>\n      </form>\n\n      <UAlert v-if=\"error\" color=\"red\" variant=\"soft\" :title=\"error\" class=\"mt-4\" />\n    </UCard>\n  </UModal>\n</template>\n\n<script setup lang=\"ts\">\nimport { channelApi } from '~/entities/channel/api';\n\nconst isOpen = defineModel<boolean>();\nconst emit = defineEmits(['added']);\n\nconst form = reactive({\n  usernameOrLink: '',\n  topic: '',\n  channelType: 'news',\n});\n\nconst loading = ref(false);\nconst error = ref('');\n\nconst handleSubmit = async () => {\n  loading.value = true;\n  error.value = '';\n\n  try {\n    const channel = await channelApi.create(form);\n    emit('added', channel);\n    isOpen.value = false;\n    form.usernameOrLink = '';\n    form.topic = '';\n    form.channelType = 'news';\n  } catch (err: any) {\n    error.value = err.message || 'Failed to add channel';\n  } finally {\n    loading.value = false;\n  }\n};\n</script>\n```\n\n4. Create apps/web/src/widgets/channel-list/ui/ChannelList.vue:\n```vue\n<template>\n  <div class=\"space-y-4\">\n    <div class=\"flex justify-between items-center\">\n      <h2 class=\"text-xl font-bold\">Channels</h2>\n      <UButton @click=\"showAddModal = true\">Add Channel</UButton>\n    </div>\n\n    <div v-if=\"loading\" class=\"space-y-2\">\n      <USkeleton v-for=\"i in 5\" :key=\"i\" class=\"h-16\" />\n    </div>\n\n    <div v-else-if=\"channels.length\" class=\"space-y-2\">\n      <UCard v-for=\"channel in channels\" :key=\"channel.id\" class=\"hover:shadow-md transition\">\n        <div class=\"flex justify-between items-start\">\n          <div>\n            <h3 class=\"font-semibold\">{{ channel.title }}</h3>\n            <p class=\"text-sm text-gray-500\">@{{ channel.username }}</p>\n            <div class=\"flex gap-2 mt-2\">\n              <UBadge>{{ channel.topic }}</UBadge>\n              <UBadge color=\"gray\">{{ channel.channelType }}</UBadge>\n            </div>\n          </div>\n          <div class=\"flex gap-1\">\n            <UButton icon=\"i-heroicons-arrow-path\" size=\"xs\" @click=\"refreshChannel(channel.id)\" />\n            <UButton icon=\"i-heroicons-trash\" color=\"red\" size=\"xs\" @click=\"deleteChannel(channel.id)\" />\n          </div>\n        </div>\n      </UCard>\n    </div>\n\n    <UAlert v-else title=\"No channels yet\" description=\"Add your first channel to get started\" />\n\n    <AddChannelModal v-model=\"showAddModal\" @added=\"loadChannels\" />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { channelApi } from '~/entities/channel/api';\nimport AddChannelModal from '~/features/add-channel/ui/AddChannelModal.vue';\nimport type { Channel } from '@telegram-crawler/types';\n\nconst channels = ref<Channel[]>([]);\nconst loading = ref(false);\nconst showAddModal = ref(false);\n\nconst loadChannels = async () => {\n  loading.value = true;\n  try {\n    channels.value = await channelApi.getAll();\n  } finally {\n    loading.value = false;\n  }\n};\n\nconst deleteChannel = async (id: string) => {\n  if (confirm('Remove this channel?')) {\n    await channelApi.delete(id);\n    await loadChannels();\n  }\n};\n\nconst refreshChannel = async (id: string) => {\n  await channelApi.refresh(id);\n  await loadChannels();\n};\n\nonMounted(loadChannels);\n</script>\n```\n\n5. Create apps/web/src/entities/post/api/index.ts:\n```typescript\nimport type { Post } from '@telegram-crawler/types';\n\ninterface FeedResponse {\n  data: Post[];\n  meta: {\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  };\n}\n\nexport const postApi = {\n  async getFeed(params?: {\n    channelId?: string;\n    topic?: string;\n    dateFrom?: string;\n    dateTo?: string;\n    page?: number;\n    limit?: number;\n  }) {\n    const api = useApi();\n    const query = new URLSearchParams();\n    Object.entries(params || {}).forEach(([key, value]) => {\n      if (value) query.append(key, String(value));\n    });\n    return api.request<FeedResponse>(`/posts?${query.toString()}`);\n  },\n\n  async search(q: string, params?: { topic?: string; dateFrom?: string; dateTo?: string; page?: number }) {\n    const api = useApi();\n    const query = new URLSearchParams({ q });\n    Object.entries(params || {}).forEach(([key, value]) => {\n      if (value) query.append(key, String(value));\n    });\n    return api.request<FeedResponse>(`/posts/search?${query.toString()}`);\n  },\n};\n```\n\n6. Create apps/web/src/widgets/feed/ui/FeedWidget.vue:\n```vue\n<template>\n  <div class=\"space-y-4\">\n    <div v-if=\"loading\" class=\"space-y-4\">\n      <USkeleton v-for=\"i in 10\" :key=\"i\" class=\"h-32\" />\n    </div>\n\n    <div v-else-if=\"posts.length\" class=\"space-y-4\">\n      <UCard v-for=\"post in posts\" :key=\"post.id\">\n        <div class=\"space-y-2\">\n          <div class=\"flex justify-between items-start\">\n            <div>\n              <UBadge>{{ post.channel?.title }}</UBadge>\n              <p class=\"text-sm text-gray-500 mt-1\">\n                {{ formatDate(post.postedAt) }}\n              </p>\n            </div>\n          </div>\n\n          <p class=\"text-base\" v-html=\"post.highlight || post.textContent\"></p>\n\n          <div v-if=\"post.hasMedia && post.mediaThumbnail\" class=\"mt-2\">\n            <img :src=\"post.mediaThumbnail\" alt=\"Post media\" class=\"rounded max-h-64 object-cover\" />\n          </div>\n\n          <div class=\"flex gap-4 text-sm text-gray-500\">\n            <span v-if=\"post.views\">{{ post.views }} views</span>\n            <span v-if=\"post.forwards\">{{ post.forwards }} forwards</span>\n          </div>\n        </div>\n      </UCard>\n    </div>\n\n    <UAlert v-else title=\"No posts found\" description=\"Try adjusting your filters\" />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type { Post } from '@telegram-crawler/types';\n\ninterface Props {\n  posts: Post[];\n  loading: boolean;\n}\n\ndefineProps<Props>();\n\nconst formatDate = (date: Date | string) => {\n  return new Date(date).toLocaleString();\n};\n</script>\n```\n\n7. Create apps/web/src/pages/index.vue:\n```vue\n<template>\n  <div class=\"min-h-screen bg-gray-50 dark:bg-gray-900\">\n    <header class=\"bg-white dark:bg-gray-800 shadow\">\n      <div class=\"max-w-7xl mx-auto px-4 py-4 flex justify-between items-center\">\n        <h1 class=\"text-2xl font-bold\">Telegram Channel Crawler</h1>\n        <UButton @click=\"handleLogout\">Logout</UButton>\n      </div>\n    </header>\n\n    <div class=\"max-w-7xl mx-auto px-4 py-8\">\n      <div class=\"grid grid-cols-1 lg:grid-cols-4 gap-8\">\n        <aside class=\"lg:col-span-1\">\n          <ChannelList />\n        </aside>\n\n        <main class=\"lg:col-span-3\">\n          <div class=\"mb-4\">\n            <UInput\n              v-model=\"searchQuery\"\n              placeholder=\"Search posts...\"\n              @input=\"debouncedSearch\"\n              icon=\"i-heroicons-magnifying-glass\"\n            />\n          </div>\n\n          <FeedWidget :posts=\"posts\" :loading=\"feedLoading\" />\n\n          <div v-if=\"meta\" class=\"mt-4 flex justify-center\">\n            <UPagination\n              v-model=\"currentPage\"\n              :total=\"meta.totalPages\"\n              @update:model-value=\"loadFeed\"\n            />\n          </div>\n        </main>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { postApi } from '~/entities/post/api';\nimport { authApi } from '~/features/auth/api';\nimport { useUserStore } from '~/entities/user/model/store';\nimport ChannelList from '~/widgets/channel-list/ui/ChannelList.vue';\nimport FeedWidget from '~/widgets/feed/ui/FeedWidget.vue';\nimport type { Post } from '@telegram-crawler/types';\nimport { useDebounceFn } from '@vueuse/core';\n\nconst posts = ref<Post[]>([]);\nconst feedLoading = ref(false);\nconst currentPage = ref(1);\nconst searchQuery = ref('');\nconst meta = ref<any>(null);\nconst userStore = useUserStore();\n\nconst loadFeed = async () => {\n  feedLoading.value = true;\n  try {\n    if (searchQuery.value) {\n      const result = await postApi.search(searchQuery.value, { page: currentPage.value });\n      posts.value = result.data;\n      meta.value = result.meta;\n    } else {\n      const result = await postApi.getFeed({ page: currentPage.value });\n      posts.value = result.data;\n      meta.value = result.meta;\n    }\n  } finally {\n    feedLoading.value = false;\n  }\n};\n\nconst debouncedSearch = useDebounceFn(() => {\n  currentPage.value = 1;\n  loadFeed();\n}, 500);\n\nconst handleLogout = async () => {\n  await authApi.logout();\n  userStore.clearUser();\n  await navigateTo('/auth/login');\n};\n\nonMounted(loadFeed);\n</script>\n```",
        "testStrategy": "1. Component tests for login page:\n   - Form validation works\n   - Login button shows loading state\n   - Error messages display correctly\n   - Successful login navigates to /\n2. Component tests for AddChannelModal:\n   - Form fields validate correctly\n   - Submit creates channel via API\n   - Error handling displays errors\n3. Component tests for ChannelList:\n   - Channels load and display\n   - Add button opens modal\n   - Delete confirms and removes channel\n   - Refresh updates channel metadata\n4. Component tests for FeedWidget:\n   - Posts render correctly\n   - Media thumbnails display\n   - Date formatting works\n   - Search highlights render HTML correctly\n5. Integration test for index page:\n   - Feed loads on mount\n   - Search debounces and updates feed\n   - Pagination works\n   - Logout clears state and redirects\n6. E2E test:\n   - Login -> view feed -> add channel -> search posts -> logout",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create login page with form validation and error handling",
            "description": "Build the authentication login page with email/password form, client-side validation, loading states, and error message display using Nuxt UI components.",
            "dependencies": [],
            "details": "Create apps/web/src/pages/auth/login.vue with UCard, UFormGroup, UInput, UButton, and UAlert components. Implement reactive form state with email and password fields. Add error state management for field-level and general errors. Include form submit handler with loading state that calls authApi.login(), handles success navigation to '/', and displays error messages on failure. Apply Tailwind classes for centered layout with dark mode support.",
            "status": "pending",
            "testStrategy": "Write component tests to verify: 1) Form fields bind correctly to reactive state, 2) Required validation prevents empty submissions, 3) Loading state disables button and shows spinner during API call, 4) Error messages display in UAlert on failed login, 5) Successful login navigates to index page and updates user store",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build API integration layer for channels",
            "description": "Implement the channel API client with methods for CRUD operations including getAll with filters, create, update, delete, and refresh functionality.",
            "dependencies": [],
            "details": "Create apps/web/src/entities/channel/api/index.ts exporting channelApi object. Implement getAll() method with optional filters (topic, channelType, isActive) using URLSearchParams for query building. Add create() method accepting usernameOrLink, topic, and channelType. Implement update() for partial channel updates and delete() for removal. Add refresh() method to trigger channel data refresh. All methods use useApi() composable and return typed Promise<Channel> or Promise<Channel[]> responses.",
            "status": "pending",
            "testStrategy": "Write unit tests with mocked useApi() to verify: 1) getAll builds correct query string with filters, 2) create sends POST with proper body structure, 3) update sends PATCH to correct endpoint, 4) delete sends DELETE request, 5) refresh triggers POST to /refresh endpoint, 6) All methods handle API errors correctly",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build API integration layer for posts and feed",
            "description": "Create the post API client with feed retrieval, search functionality, and pagination support using typed response interfaces.",
            "dependencies": [],
            "details": "Create apps/web/src/entities/post/api/index.ts with FeedResponse interface containing data array and meta object (total, page, limit, totalPages). Implement postApi.getFeed() accepting optional params for channelId, topic, dateFrom, dateTo, page, and limit. Add postApi.search() method with query string 'q' and optional filtering params. Both methods build URLSearchParams from provided options and return typed FeedResponse promises using useApi() composable.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify: 1) getFeed constructs correct query parameters from filters, 2) search includes 'q' parameter and optional filters, 3) Pagination params (page, limit) are correctly appended, 4) Empty/undefined params are excluded from query string, 5) Response structure matches FeedResponse type definition",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create AddChannelModal with form validation",
            "description": "Build reusable modal component for adding new channels with form fields for username/link, topic, and type selection including validation and error handling.",
            "dependencies": [
              2
            ],
            "details": "Create apps/web/src/features/add-channel/ui/AddChannelModal.vue using UModal and UCard components. Implement v-model binding for modal open state. Add form with UFormGroup/UInput for usernameOrLink (accepts @channel or t.me/channel format), topic input, and USelect for channelType with options ['news', 'personal_blog', 'official']. Include reactive form state, loading state, and error message display. Implement handleSubmit that calls channelApi.create(), emits 'added' event with created channel, resets form, and closes modal on success. Show error in UAlert on failure.",
            "status": "pending",
            "testStrategy": "Component tests should verify: 1) Modal opens/closes correctly with v-model, 2) Form fields validate required inputs, 3) Channel type dropdown shows all options, 4) Submit button shows loading state during API call, 5) Success emits 'added' event and closes modal, 6) Errors display in UAlert, 7) Form resets after successful submission",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build ChannelList widget with CRUD operations",
            "description": "Create the channel list sidebar widget displaying all channels with add/refresh/delete actions, loading states, and empty state handling.",
            "dependencies": [
              2,
              4
            ],
            "details": "Create apps/web/src/widgets/channel-list/ui/ChannelList.vue with channels array ref and loading state. Implement loadChannels() async function calling channelApi.getAll(). Display loading skeleton (USkeleton) when fetching, empty state (UAlert) when no channels exist, or grid of UCard components for each channel showing title, username, topic/type badges. Add header with 'Add Channel' button triggering AddChannelModal. Include action buttons for refresh (calls channelApi.refresh) and delete (shows confirmation, calls channelApi.delete). Call loadChannels() on mount and after add/delete operations.",
            "status": "pending",
            "testStrategy": "Component tests should verify: 1) Loading state shows skeletons, 2) Empty state displays when channels array is empty, 3) Channel cards render with correct data (title, username, badges), 4) Add button opens AddChannelModal, 5) Delete shows confirmation and removes channel, 6) Refresh updates single channel data, 7) List reloads after successful add/delete operations",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement FeedWidget with post cards and media display",
            "description": "Build the feed widget component that displays post cards with content, media thumbnails, metadata, and proper HTML highlight rendering.",
            "dependencies": [
              3
            ],
            "details": "Create apps/web/src/widgets/feed/ui/FeedWidget.vue accepting posts array and loading boolean as props. Display loading skeletons (USkeleton) when loading is true. Render UCard for each post showing channel badge, formatted date (using formatDate helper), text content with v-html for highlight support (ensure proper sanitization), optional media thumbnail image with max-height constraint, and engagement metrics (views, forwards). Show empty state UAlert when no posts exist. Include formatDate utility function converting Date/string to localized string format.",
            "status": "pending",
            "testStrategy": "Component tests should verify: 1) Loading prop triggers skeleton display, 2) Posts render in individual cards, 3) Channel name and date display correctly, 4) v-html renders highlight content (test with sanitized HTML), 5) Media thumbnails show when hasMedia is true, 6) Views/forwards display when present, 7) Empty state shows for empty posts array, 8) XSS protection prevents script execution in highlights",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Create search input with debouncing",
            "description": "Implement debounced search input component that triggers feed updates after user stops typing, preventing excessive API calls.",
            "dependencies": [
              3
            ],
            "details": "In apps/web/src/pages/index.vue, add UInput component with v-model bound to searchQuery ref, placeholder 'Search posts...', and magnifying glass icon. Import useDebounceFn from @vueuse/core. Create debouncedSearch function wrapping loadFeed() call with 500ms delay using useDebounceFn. Bind @input event to debouncedSearch. Ensure search resets currentPage to 1 before triggering loadFeed. Modify loadFeed() to check searchQuery value and call either postApi.search() or postApi.getFeed() accordingly, passing current page parameter.",
            "status": "pending",
            "testStrategy": "Component tests should verify: 1) Search input binds to searchQuery ref, 2) Input changes trigger debounced function (not immediate), 3) Function executes 500ms after last keystroke, 4) Search resets page to 1, 5) Non-empty query calls postApi.search(), 6) Empty query calls postApi.getFeed(), 7) Loading state prevents multiple simultaneous searches",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Build pagination component integration",
            "description": "Add pagination controls to the feed using UPagination component with page state management and feed reload on page change.",
            "dependencies": [
              3,
              6
            ],
            "details": "In apps/web/src/pages/index.vue, add currentPage ref initialized to 1 and meta ref for pagination metadata. Display UPagination component below FeedWidget bound to currentPage with v-model, :total set to meta.totalPages. Add @update:model-value listener calling loadFeed(). Update loadFeed() to pass currentPage in params to both postApi.search() and postApi.getFeed(). Store returned meta object containing total, page, limit, and totalPages in meta ref. Only render pagination when meta exists and has multiple pages.",
            "status": "pending",
            "testStrategy": "Component tests should verify: 1) Pagination component renders when meta exists, 2) Current page binds correctly to v-model, 3) Page change triggers loadFeed() call, 4) API receives correct page parameter, 5) Meta updates after feed loads, 6) Total pages calculated correctly, 7) Pagination hidden when only one page exists, 8) Page state persists during search",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement main index page layout with authentication",
            "description": "Build the main application page combining header, channel list sidebar, feed widget, and search/pagination into responsive grid layout with logout functionality.",
            "dependencies": [
              5,
              6,
              7,
              8
            ],
            "details": "Create apps/web/src/pages/index.vue with full layout: header bar containing app title and logout button, responsive grid with lg:grid-cols-4 (1 column for ChannelList sidebar, 3 for main feed area). Import and render ChannelList in aside, FeedWidget in main section with posts and feedLoading props. Add search input above feed and UPagination below. Initialize posts array, feedLoading, currentPage, searchQuery, and meta refs. Implement loadFeed() combining search/feed logic. Add handleLogout() calling authApi.logout(), clearing userStore, and navigating to /auth/login. Call loadFeed() on mount. Apply Tailwind classes for spacing, backgrounds, and dark mode support.",
            "status": "pending",
            "testStrategy": "Integration tests should verify: 1) Page renders all widgets (header, sidebar, feed, search, pagination), 2) Layout is responsive (sidebar stacks on mobile), 3) Logout clears auth and redirects to login, 4) Feed loads on mount, 5) Search updates feed, 6) Pagination changes feed page, 7) Channel add/delete updates sidebar and feed if needed, 8) Loading states display correctly across widgets, 9) Dark mode styles apply properly",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 9,
        "expansionPrompt": "Divide into: 1) Create login page with form validation and error handling, 2) Build API integration layer for auth/channels/posts, 3) Create AddChannelModal with form validation, 4) Build ChannelList widget with CRUD operations, 5) Implement FeedWidget with post cards and media display, 6) Create search input with debouncing, 7) Build pagination component, 8) Implement main index page layout, 9) Write component tests for critical UI flows"
      },
      {
        "id": "10",
        "title": "Implement Media Processing and Docker Deployment",
        "description": "Add thumbnail generation with Sharp, implement on-demand media fetching endpoint, create Docker Compose setup for all services (PostgreSQL, Redis, API, Web), and write deployment documentation.",
        "details": "1. Create apps/api/src/modules/crawler/media.service.ts:\n```typescript\nimport { Injectable, Logger } from '@nestjs/common';\nimport { TelegramService } from './telegram.service';\nimport * as sharp from 'sharp';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\n@Injectable()\nexport class MediaService {\n  private readonly logger = new Logger(MediaService.name);\n  private readonly thumbnailDir = path.join(process.cwd(), 'storage', 'thumbnails');\n\n  constructor(private telegramService: TelegramService) {\n    this.ensureDirectories();\n  }\n\n  private async ensureDirectories() {\n    await fs.mkdir(this.thumbnailDir, { recursive: true });\n  }\n\n  async generateThumbnail(buffer: Buffer, fileId: string): Promise<string> {\n    try {\n      const thumbnailPath = path.join(this.thumbnailDir, `${fileId}.jpg`);\n      \n      await sharp(buffer)\n        .resize(200, 200, { fit: 'cover' })\n        .jpeg({ quality: 80 })\n        .toFile(thumbnailPath);\n      \n      return `/thumbnails/${fileId}.jpg`;\n    } catch (error) {\n      this.logger.error(`Failed to generate thumbnail for ${fileId}`, error);\n      throw error;\n    }\n  }\n\n  async getThumbnailPath(fileId: string): Promise<string | null> {\n    const thumbnailPath = path.join(this.thumbnailDir, `${fileId}.jpg`);\n    try {\n      await fs.access(thumbnailPath);\n      return thumbnailPath;\n    } catch {\n      return null;\n    }\n  }\n\n  async cleanupOldThumbnails(maxAgeHours = 24) {\n    const now = Date.now();\n    const maxAge = maxAgeHours * 60 * 60 * 1000;\n\n    try {\n      const files = await fs.readdir(this.thumbnailDir);\n      \n      for (const file of files) {\n        const filePath = path.join(this.thumbnailDir, file);\n        const stats = await fs.stat(filePath);\n        \n        if (now - stats.mtimeMs > maxAge) {\n          await fs.unlink(filePath);\n          this.logger.log(`Deleted old thumbnail: ${file}`);\n        }\n      }\n    } catch (error) {\n      this.logger.error('Failed to cleanup thumbnails', error);\n    }\n  }\n}\n```\n\n2. Update CrawlChannelProcessor to generate thumbnails:\n```typescript\n// In apps/api/src/modules/crawler/jobs/crawl-channel.job.ts\n// Add MediaService injection and thumbnail generation for photos\n\nconstructor(\n  private telegramService: TelegramService,\n  private mediaService: MediaService,\n  @InjectRepository(Channel)\n  private channelsRepository: Repository<Channel>,\n  @InjectRepository(Post)\n  private postsRepository: Repository<Post>,\n) {\n  super();\n}\n\n// After saving post with media, generate thumbnail:\nif (msg.hasMedia && msg.mediaType === 'photo' && msg.mediaFileId) {\n  try {\n    const buffer = await this.telegramService.downloadMedia(msg.mediaFileId, 'photo');\n    const thumbnailUrl = await this.mediaService.generateThumbnail(buffer, msg.mediaFileId);\n    post.mediaThumbnail = thumbnailUrl;\n    await this.postsRepository.save(post);\n  } catch (error) {\n    this.logger.warn(`Failed to generate thumbnail for post ${post.id}`, error);\n  }\n}\n```\n\n3. Add static file serving in apps/api/src/main.ts:\n```typescript\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { ValidationPipe } from '@nestjs/common';\nimport { HttpExceptionFilter } from './common/filters/http-exception.filter';\nimport * as express from 'express';\nimport * as path from 'path';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  app.setGlobalPrefix('api');\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.useGlobalFilters(new HttpExceptionFilter());\n  app.enableCors();\n  \n  // Serve static thumbnails\n  app.use('/thumbnails', express.static(path.join(process.cwd(), 'storage', 'thumbnails')));\n  \n  await app.listen(3001);\n  console.log('API running on http://localhost:3001');\n}\nbootstrap();\n```\n\n4. Create docker-compose.yml in project root:\n```yaml\nversion: '3.9'\n\nservices:\n  postgres:\n    image: postgres:16-alpine\n    environment:\n      POSTGRES_USER: telegram_crawler\n      POSTGRES_PASSWORD: ${DB_PASSWORD}\n      POSTGRES_DB: telegram_crawler\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U telegram_crawler\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  redis:\n    image: redis:7-alpine\n    command: redis-server --requirepass ${REDIS_PASSWORD}\n    volumes:\n      - redis_data:/data\n    ports:\n      - \"6379:6379\"\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"--raw\", \"incr\", \"ping\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  api:\n    build:\n      context: .\n      dockerfile: ./apps/api/Dockerfile\n    environment:\n      DB_HOST: postgres\n      DB_PORT: 5432\n      DB_USERNAME: telegram_crawler\n      DB_PASSWORD: ${DB_PASSWORD}\n      DB_NAME: telegram_crawler\n      REDIS_HOST: redis\n      REDIS_PORT: 6379\n      REDIS_PASSWORD: ${REDIS_PASSWORD}\n      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}\n      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}\n      TELEGRAM_API_ID: ${TELEGRAM_API_ID}\n      TELEGRAM_API_HASH: ${TELEGRAM_API_HASH}\n      TELEGRAM_SESSION_STRING: ${TELEGRAM_SESSION_STRING}\n      NODE_ENV: production\n    ports:\n      - \"3001:3001\"\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    volumes:\n      - api_storage:/app/storage\n    restart: unless-stopped\n\n  web:\n    build:\n      context: .\n      dockerfile: ./apps/web/Dockerfile\n    environment:\n      NUXT_PUBLIC_API_BASE: http://localhost:3001/api\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - api\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n  redis_data:\n  api_storage:\n```\n\n5. Create apps/api/Dockerfile:\n```dockerfile\nFROM node:20-alpine AS base\nRUN corepack enable && corepack prepare pnpm@latest --activate\nWORKDIR /app\n\nFROM base AS deps\nCOPY package.json pnpm-workspace.yaml pnpm-lock.yaml ./\nCOPY apps/api/package.json ./apps/api/\nCOPY packages/types/package.json ./packages/types/\nRUN pnpm install --frozen-lockfile\n\nFROM base AS builder\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\nRUN pnpm --filter @telegram-crawler/api build\n\nFROM base AS runner\nENV NODE_ENV=production\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY --from=builder /app/apps/api/dist ./apps/api/dist\nCOPY --from=builder /app/packages ./packages\nCOPY apps/api/package.json ./apps/api/\nRUN mkdir -p /app/storage/thumbnails\nEXPOSE 3001\nCMD [\"node\", \"apps/api/dist/main.js\"]\n```\n\n6. Create apps/web/Dockerfile:\n```dockerfile\nFROM node:20-alpine AS base\nRUN corepack enable && corepack prepare pnpm@latest --activate\nWORKDIR /app\n\nFROM base AS deps\nCOPY package.json pnpm-workspace.yaml pnpm-lock.yaml ./\nCOPY apps/web/package.json ./apps/web/\nCOPY packages/types/package.json ./packages/types/\nRUN pnpm install --frozen-lockfile\n\nFROM base AS builder\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\nRUN pnpm --filter @telegram-crawler/web build\n\nFROM base AS runner\nENV NODE_ENV=production\nCOPY --from=builder /app/apps/web/.output /app/.output\nEXPOSE 3000\nCMD [\"node\", \".output/server/index.mjs\"]\n```\n\n7. Create .env.example in root:\n```\nDB_PASSWORD=your_secure_password\nREDIS_PASSWORD=your_redis_password\nJWT_ACCESS_SECRET=your_jwt_access_secret_min_32_characters\nJWT_REFRESH_SECRET=your_jwt_refresh_secret_min_32_characters\nTELEGRAM_API_ID=your_telegram_api_id\nTELEGRAM_API_HASH=your_telegram_api_hash\nTELEGRAM_SESSION_STRING=your_session_string\n```\n\n8. Create DEPLOYMENT.md:\n```markdown\n# Deployment Guide\n\n## Prerequisites\n- Docker and Docker Compose installed\n- Telegram API credentials (api_id, api_hash from https://my.telegram.org)\n- Telegram session string (generate using authentication script)\n\n## Setup Steps\n\n1. Clone repository and navigate to project root\n\n2. Copy environment file:\n   ```bash\n   cp .env.example .env\n   ```\n\n3. Edit .env and fill in all required values\n\n4. Generate Telegram session:\n   ```bash\n   cd apps/api\n   pnpm tsx scripts/generate-session.ts\n   ```\n   Follow prompts to authenticate and copy session string to .env\n\n5. Build and start services:\n   ```bash\n   docker-compose up -d\n   ```\n\n6. Run database migrations:\n   ```bash\n   docker-compose exec api pnpm typeorm migration:run\n   ```\n\n7. Create initial admin user:\n   ```bash\n   docker-compose exec api pnpm tsx scripts/create-admin.ts\n   ```\n\n8. Access application:\n   - Frontend: http://localhost:3000\n   - API: http://localhost:3001\n\n## Monitoring\n\n- View logs: `docker-compose logs -f`\n- View API logs: `docker-compose logs -f api`\n- View crawler jobs: Access BullMQ dashboard (optional addon)\n\n## Backup\n\n```bash\n# Backup database\ndocker-compose exec postgres pg_dump -U telegram_crawler telegram_crawler > backup.sql\n\n# Backup thumbnails\ntar -czf thumbnails.tar.gz storage/thumbnails/\n```\n\n## Troubleshooting\n\n- If Telegram client fails to connect, verify session string is valid\n- Check FLOOD_WAIT errors in logs and adjust crawler frequency\n- Ensure PostgreSQL full-text search indexes are created\n```\n\n9. Create apps/api/scripts/generate-session.ts:\n```typescript\nimport { TelegramClient } from 'telegram';\nimport { StringSession } from 'telegram/sessions';\nimport * as readline from 'readline';\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst question = (query: string): Promise<string> => {\n  return new Promise(resolve => rl.question(query, resolve));\n};\n\nasync function main() {\n  const apiId = parseInt(await question('Enter API ID: '));\n  const apiHash = await question('Enter API Hash: ');\n  const phoneNumber = await question('Enter phone number: ');\n\n  const client = new TelegramClient(new StringSession(''), apiId, apiHash, {\n    connectionRetries: 5,\n  });\n\n  await client.start({\n    phoneNumber: async () => phoneNumber,\n    password: async () => await question('Enter password (if 2FA enabled): '),\n    phoneCode: async () => await question('Enter code from Telegram: '),\n    onError: (err) => console.error(err),\n  });\n\n  console.log('\\nAuthentication successful!');\n  console.log('\\nSession string:');\n  console.log(client.session.save());\n  console.log('\\nCopy this to TELEGRAM_SESSION_STRING in .env file\\n');\n\n  await client.disconnect();\n  rl.close();\n}\n\nmain();\n```",
        "testStrategy": "1. Unit tests for MediaService:\n   - generateThumbnail creates 200x200 JPEG\n   - getThumbnailPath returns correct path or null\n   - cleanupOldThumbnails deletes files older than maxAge\n2. Integration test:\n   - Upload test image buffer\n   - Verify thumbnail generated\n   - Verify thumbnail accessible via HTTP\n3. Docker deployment test:\n   - Build all images successfully\n   - docker-compose up starts all services\n   - Health checks pass for postgres and redis\n   - API accessible at http://localhost:3001\n   - Web accessible at http://localhost:3000\n4. Migration test:\n   - Run migrations in Docker container\n   - Verify all tables created\n   - Verify full-text search indexes exist\n5. E2E deployment test:\n   - Deploy with docker-compose\n   - Login to web app\n   - Add channel\n   - Wait for crawl job\n   - Verify posts appear in feed\n   - Verify thumbnails load\n6. Backup/restore test:\n   - Create backup\n   - Destroy volumes\n   - Restore backup\n   - Verify data intact",
        "priority": "medium",
        "dependencies": [
          "7",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create MediaService with Sharp for thumbnail generation",
            "description": "Implement MediaService class with Sharp library for generating 200x200 JPEG thumbnails from image buffers with proper error handling and logging.",
            "dependencies": [],
            "details": "Create apps/api/src/modules/crawler/media.service.ts with MediaService class. Implement generateThumbnail method that uses Sharp to resize images to 200x200 with fit: 'cover', converts to JPEG with 80% quality, and saves to storage/thumbnails directory. Include error handling with Logger for failed thumbnail generation. Method should return relative URL path /thumbnails/{fileId}.jpg for use in database.",
            "status": "pending",
            "testStrategy": "Unit test: Mock Sharp library and verify resize(200, 200, {fit: 'cover'}), jpeg({quality: 80}), and toFile() are called correctly. Test error handling by mocking Sharp to throw error. Verify Logger.error is called with correct parameters on failure.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement thumbnail storage and cleanup logic",
            "description": "Add directory initialization, thumbnail path resolution, and automated cleanup of old thumbnails based on configurable age threshold.",
            "dependencies": [
              1
            ],
            "details": "In MediaService, implement ensureDirectories() to create storage/thumbnails directory recursively. Add getThumbnailPath() method that checks if thumbnail exists using fs.access and returns file path or null. Implement cleanupOldThumbnails(maxAgeHours = 24) that reads thumbnailDir, iterates files, checks mtime, and deletes files older than maxAge. Include comprehensive error handling and logging for cleanup failures.",
            "status": "pending",
            "testStrategy": "Unit tests: Mock fs.mkdir to verify recursive: true option. Test getThumbnailPath returns path for existing file and null for missing file. Test cleanupOldThumbnails deletes files with mtime > maxAge and skips newer files. Verify error handling logs errors without throwing.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add static file serving to NestJS main.ts",
            "description": "Configure Express static middleware to serve thumbnail images from storage/thumbnails directory at /thumbnails URL path.",
            "dependencies": [
              2
            ],
            "details": "Update apps/api/src/main.ts to import express and path modules. After CORS setup and before app.listen(), add app.use('/thumbnails', express.static(path.join(process.cwd(), 'storage', 'thumbnails'))). This enables direct HTTP access to generated thumbnails via GET /thumbnails/{fileId}.jpg URLs.",
            "status": "pending",
            "testStrategy": "Integration test: Start application, generate test thumbnail, make HTTP GET request to /thumbnails/{fileId}.jpg, verify 200 status and image/jpeg content-type. Test 404 for non-existent thumbnail. Verify no directory traversal vulnerability with ../.. in path.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate thumbnail generation into crawler job",
            "description": "Update CrawlChannelProcessor to inject MediaService and generate thumbnails for photo posts during crawling process.",
            "dependencies": [
              3
            ],
            "details": "In apps/api/src/modules/crawler/jobs/crawl-channel.job.ts, add MediaService to constructor injection. After saving post with mediaType === 'photo' and mediaFileId, call telegramService.downloadMedia() to get buffer, then mediaService.generateThumbnail() to create thumbnail. Update post.mediaThumbnail field with returned URL and save. Wrap in try-catch to log warnings without failing entire crawl if thumbnail generation fails.",
            "status": "pending",
            "testStrategy": "Integration test: Mock TelegramService.downloadMedia to return test image buffer. Trigger crawl job for channel with photo posts. Verify post.mediaThumbnail is populated with /thumbnails/{fileId}.jpg URL. Verify thumbnail file exists in storage directory. Test graceful degradation when thumbnail generation fails.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Dockerfile for API with multi-stage build",
            "description": "Build optimized production Docker image for NestJS API using multi-stage build pattern with pnpm workspace support and minimal runtime dependencies.",
            "dependencies": [],
            "details": "Create apps/api/Dockerfile with 4 stages: base (node:20-alpine with pnpm), deps (install dependencies with frozen lockfile), builder (build TypeScript), runner (production runtime). Copy only necessary files at each stage. Configure NODE_ENV=production. Create /app/storage/thumbnails directory for volume mounting. Expose port 3001 and set CMD to node apps/api/dist/main.js. Use --frozen-lockfile for deterministic builds.",
            "status": "pending",
            "testStrategy": "Build test: Run docker build -f apps/api/Dockerfile . and verify successful build. Verify image size is optimized (< 500MB). Test container starts with docker run and responds to health check. Verify pnpm workspace structure is preserved and @telegram-crawler/types package is accessible.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create Dockerfile for Web with Nuxt build optimization",
            "description": "Build production Docker image for Nuxt.js web application with optimized SSR output and minimal runtime footprint.",
            "dependencies": [],
            "details": "Create apps/web/Dockerfile with 4 stages: base (node:20-alpine with pnpm), deps (install frozen lockfile), builder (run nuxt build), runner (copy .output and serve). Set NODE_ENV=production in runner stage. Copy only apps/web/.output directory to minimize image size. Expose port 3000. Set CMD to node .output/server/index.mjs for Nuxt SSR server.",
            "status": "pending",
            "testStrategy": "Build test: Run docker build -f apps/web/Dockerfile . and verify build completes. Check image size is optimized (< 300MB). Test container starts and Nuxt SSR responds on port 3000. Verify environment variables (NUXT_PUBLIC_API_BASE) are correctly injected at runtime.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Write docker-compose.yml with all services",
            "description": "Create comprehensive Docker Compose configuration orchestrating PostgreSQL, Redis, API, and Web services with proper networking and volume management.",
            "dependencies": [
              5,
              6
            ],
            "details": "Create docker-compose.yml version 3.9 in project root. Define 4 services: postgres (postgres:16-alpine), redis (redis:7-alpine with password auth), api (build from apps/api/Dockerfile), web (build from apps/web/Dockerfile). Configure environment variables using ${VAR} substitution from .env file. Define named volumes: postgres_data, redis_data, api_storage for persistence. Map ports: postgres:5432, redis:6379, api:3001, web:3000.",
            "status": "pending",
            "testStrategy": "Integration test: Run docker-compose up -d and verify all 4 services start. Check docker-compose ps shows all healthy. Verify API can connect to postgres and redis. Test web can reach API. Verify volumes persist data after docker-compose down && docker-compose up.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Configure service dependencies and health checks",
            "description": "Implement health checks for database services and configure service startup dependencies to ensure proper initialization order.",
            "dependencies": [
              7
            ],
            "details": "Add healthcheck to postgres service: pg_isready -U telegram_crawler with 10s interval, 5s timeout, 5 retries. Add healthcheck to redis: redis-cli --raw incr ping with same timing. Configure api service with depends_on using condition: service_healthy for both postgres and redis. Set restart: unless-stopped for api and web services. Configure web depends_on api without health check condition.",
            "status": "pending",
            "testStrategy": "Test: Run docker-compose up and verify services start in order: postgres/redis -> wait for healthy -> api -> web. Simulate postgres failure (docker-compose stop postgres) and verify API container restarts when postgres recovers. Check docker-compose logs shows health check execution.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Create environment configuration and example file",
            "description": "Define all required environment variables for production deployment and create .env.example template with documentation.",
            "dependencies": [],
            "details": "Create .env.example in project root with all required variables: DB_PASSWORD, REDIS_PASSWORD, JWT_ACCESS_SECRET (min 32 chars), JWT_REFRESH_SECRET (min 32 chars), TELEGRAM_API_ID, TELEGRAM_API_HASH, TELEGRAM_SESSION_STRING. Add comments explaining where to obtain each value (e.g., Telegram credentials from my.telegram.org). Include placeholder values showing expected format but not actual secrets.",
            "status": "pending",
            "testStrategy": "Validation test: Verify .env.example contains all variables referenced in docker-compose.yml and application config files. Test docker-compose config fails with helpful error when .env is missing required values. Document validation: Ensure comments clearly explain credential acquisition process.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Write Telegram session generation script",
            "description": "Create interactive CLI script for authenticating with Telegram and generating session string required for GramJS client initialization.",
            "dependencies": [],
            "details": "Create apps/api/scripts/generate-session.ts using TelegramClient and StringSession from telegram library. Implement readline interface for interactive prompts: API ID, API Hash, phone number, password (if 2FA), and phone code. Use client.start() with async prompt callbacks. On successful auth, output client.session.save() session string with instructions to copy to TELEGRAM_SESSION_STRING in .env. Include error handling and connection retry configuration (connectionRetries: 5).",
            "status": "pending",
            "testStrategy": "Manual test: Run pnpm tsx scripts/generate-session.ts with valid test Telegram account. Verify prompts appear correctly. Enter valid credentials and verify session string is output. Copy session string to .env and verify TelegramService can initialize client. Test error handling with invalid credentials.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Create comprehensive deployment documentation",
            "description": "Write complete DEPLOYMENT.md guide covering prerequisites, setup steps, monitoring, backup procedures, and troubleshooting for production deployment.",
            "dependencies": [
              8,
              9,
              10
            ],
            "details": "Create DEPLOYMENT.md in project root with sections: Prerequisites (Docker, Docker Compose, Telegram credentials), Setup Steps (clone repo, copy .env, generate session, docker-compose up, run migrations, create admin user, access URLs), Monitoring (docker-compose logs commands), Backup (pg_dump for database, tar for thumbnails), Troubleshooting (Telegram session errors, FLOOD_WAIT handling, database index verification). Include exact commands with syntax highlighting. Reference session generation script and migration execution in Docker context.",
            "status": "pending",
            "testStrategy": "Documentation test: Follow DEPLOYMENT.md on fresh Ubuntu VPS or macOS machine with only Docker installed. Verify each command executes successfully. Check all links are valid. Ensure troubleshooting section covers common errors seen in logs. Validate backup/restore procedure works with test data.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 11,
        "expansionPrompt": "Break down into: 1) Create MediaService with Sharp for thumbnail generation, 2) Implement thumbnail storage and cleanup logic, 3) Add static file serving to NestJS, 4) Integrate thumbnail generation into crawler job, 5) Create Dockerfile for API with multi-stage build, 6) Create Dockerfile for Web with Nuxt build optimization, 7) Write docker-compose.yml with all services, 8) Configure service dependencies and health checks, 9) Create migration runner script for Docker, 10) Write session generation script for Telegram auth, 11) Create comprehensive deployment documentation"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-30T20:47:26.676Z",
      "taskCount": 10,
      "completedCount": 3,
      "tags": [
        "master"
      ]
    }
  }
}